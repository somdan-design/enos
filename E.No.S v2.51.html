<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <title>E.No.S v2.51 (Text Only)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Noto+Serif+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 설정 */
        body { 
            font-family: 'Noto Sans KR', sans-serif; 
            overscroll-behavior: none; 
            user-select: none; 
            -webkit-user-select: none;
            touch-action: manipulation; 
        }
        
        /* 텍스트 선택 허용 영역 */
        input, textarea, [contenteditable="true"], .selectable-text, 
        .msg-wrapper .novel-text, .rule-content, .world-chars, .gen-section, .selectable { 
            user-select: text !important; 
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            cursor: text;
        }


        /* 폰트 사이즈 변수 */
        :root { --novel-font-size: 1.1rem; }


        /* 리스트 스타일 복구 */
        .novel-text ol { list-style-type: decimal; padding-left: 1.5rem; margin: 0.5rem 0; }
        .novel-text ul { list-style-type: disc; padding-left: 1.5rem; margin: 0.5rem 0; }
        .novel-text li { margin-bottom: 0.25rem; }
        .novel-text li p { margin: 0; display: inline-block; }


        button {
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
            touch-action: manipulation;
        }


        .serif { font-family: 'Noto Serif KR', serif; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        #input-area { padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
        #sidebar, #right-sidebar { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }


        /* 채팅창 너비 고정 및 중앙 정렬 강화 */
        .msg-container { max-width: 800px; margin: 0 auto; padding: 0 1.5rem; width: 100%; box-sizing: border-box; }
        .msg-wrapper { display: block; margin-bottom: 2rem; position: relative; }
        
        .msg-wrapper.user .novel-text { 
            font-family: 'Noto Sans KR', sans-serif; font-weight: 700; color: #4f46e5; background-color: #eef2ff;
            padding: 0.75rem 1.25rem; border-left: 4px solid #4f46e5; border-radius: 0 0.75rem 0.75rem 0; display: inline-block; margin-bottom: 0.5rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            font-size: var(--novel-font-size);
        }
        
.novel-text {
    overflow-wrap: anywhere; 
    word-break: break-word;
    white-space: normal !important;
}


.novel-text p { 
    margin: 0 !important; 
    padding: 0 !important; 
margin-bottom: 0 !important; /* 문단 사이 숨통 트임 */
    line-height: 1.8 !important; /* 대신 줄 간격을 적당히 벌림 */
    min-height: 1.2em; /* 빈 줄이 있어도 높이 유지 */
}

        .novel-text p:last-child { margin-bottom: 0 !important; }


        .msg-wrapper.model .novel-text { 
            font-family: 'Noto Serif KR', serif; 
            font-size: var(--novel-font-size);
            line-height: 1.9; color: #1e293b; text-align: justify;
        }
        
        .msg-wrapper.director .novel-text {
            font-family: 'Noto Sans KR', sans-serif; font-size: 0.95rem; color: #475569; background-color: #f1f5f9;
            padding: 1rem; border: 2px dashed #94a3b8; border-radius: 0.5rem; width: 100%; display: block;
        }
        .msg-wrapper.director::before { content: '   총연출가'; display: block; font-size: 0.75rem; color: #64748b; margin-bottom: 0.25rem; font-weight: bold; margin-left: 0.2rem; }


        .nav-btn.active { color: #4f46e5; border-bottom: 2px solid #4f46e5; }
        
        .editor-tab-btn { padding: 0.5rem 0.75rem; color: #64748b; border-bottom: 2px solid transparent; font-weight: 500; font-size: 0.9rem; white-space: nowrap; }
        .editor-tab-btn.active { color: #4f46e5; border-bottom-color: #4f46e5; font-weight: 700; }


        .generator-tab-btn { flex:1; padding: 0.5rem; text-align: center; font-size: 0.85rem; font-weight: bold; color: #64748b; background: #f1f5f9; border-bottom: 2px solid transparent; }
        .generator-tab-btn.active { color: #4f46e5; border-bottom-color: #4f46e5; background: white; }
        
        .world-select-btn { text-align: left; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 0.5rem; transition: 0.2s; }
        .world-select-btn:hover { border-color: #6366f1; background-color: #eef2ff; }
        .world-select-btn.selected { border-color: #4f46e5; background-color: #e0e7ff; ring: 2px solid #6366f1; }


        .keyword-tag { padding: 0.3rem 0.7rem; border-radius: 9999px; font-size: 0.85rem; font-weight: 500; background-color: white; color: #334155; border: 1px solid #cbd5e1; cursor: pointer; transition: 0.15s; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .keyword-tag:hover { background-color: #f1f5f9; border-color: #94a3b8; }
        .keyword-tag.active { background-color: #334155; color: #fcd34d; border-color: #0f172a; } 


        .rule-item.collapsed .rule-content { display: none; }
        .rule-item .rule-header i.fa-chevron-down { transition: transform 0.2s; }
        .rule-item.collapsed .rule-header i.fa-chevron-down { transform: rotate(-90deg); }
        .rule-item.disabled .rule-header { background-color: #f3f4f6; color: #9ca3af; }
        .rule-item.disabled .rule-header .font-bold { text-decoration: line-through; }


        .world-item .world-chars { display: none; }
        .world-item.open .world-chars { display: block; }
        .world-item.open .world-header { background-color: #eff6ff; border-color: #bfdbfe; border-radius: 0.5rem 0.5rem 0 0; }


        #sidebar, #right-sidebar { overflow: hidden; transition: width 0.3s, transform 0.3s; }
        
        /* PC 사이드바 */
        @media (min-width: 768px) { 
            #sidebar, #right-sidebar { width: 320px; flex-shrink: 0; } 
            #sidebar.closed, #right-sidebar.closed { width: 0; padding-left: 0; padding-right: 0; border-left: none; border-right: none; } 
        }
        /* 모바일 사이드바 */
        @media (max-width: 767px) { 
            #sidebar, #right-sidebar { position: fixed; top: 0; height: 100%; z-index: 60; width: 85%; max-width: 320px; } 
            #sidebar { left: 0; transform: translateX(-100%); } #sidebar.open { transform: translateX(0); } 
            #right-sidebar { right: 0; transform: translateX(100%); } #right-sidebar.open { transform: translateX(0); } 
        }
        
        .gen-section.hidden-section { display: none; }
        .gen-section.hidden-section.show { display: block; animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        
        .modal-backdrop { background-color: rgba(0, 0, 0, 0.6); }


/* ▼▼▼ [수정됨] 개선된 다크 모드 스타일 (기존 내용을 지우고 덮어씌우세요) ▼▼▼ */
        html.dark body { background-color: #0f172a !important; color: #f1f5f9 !important; }
        
        /* 1. 메인 컨테이너 및 모달 배경 (너무 검지 않은 고급스러운 다크 그레이) */
        html.dark .bg-white, html.dark .bg-gray-50, html.dark .bg-gray-100 { 
            background-color: #1e293b !important; /* Slate 800 */
            border-color: #334155 !important;     /* Slate 700 */
            color: #f8fafc !important; 
        }
        
        /* 2. 사이드바 및 헤더 (본문보다 살짝 더 어둡게 눌러줌) */
        html.dark #sidebar, html.dark #right-sidebar, html.dark header, html.dark footer {
            background-color: #0f172a !important; /* Slate 900 */
            border-color: #1e293b !important;
        }


/* ▼▼▼ [수정] 사이드바 토글 버튼: 4지선다(선택지) 스타일 적용 ▼▼▼ */
/* 평소 상태: 선택지 테두리 색상과 비슷하게 은은하게 설정 */
html.dark button[onclick="toggleSidebar()"],
html.dark button[onclick="toggleRightSidebar()"] {
    color: #94a3b8 !important; /* Slate 400 (차분한 톤) */
    transition: all 0.2s ease-in-out;
}


/* 마우스 올렸을 때 (Hover): 4지선다 선택지와 동일한 인디고 컬러 적용 */
html.dark button[onclick="toggleSidebar()"]:hover,
html.dark button[onclick="toggleRightSidebar()"]:hover {
    background-color: #312e81 !important; /* bg-indigo-50의 다크모드 대응색 (진한 남색) */
    color: #e0e7ff !important;           /* 텍스트는 밝은 인디고 (빛나는 느낌) */
    border-color: #4338ca !important;    /* 테두리도 인디고 계열 */
    box-shadow: 0 0 10px rgba(99, 102, 241, 0.3); /* 살짝 빛나는 효과 (선택지 강조 효과 재사용) */
}
        
        /* 3. 텍스트 가독성 개선 (회색 글씨를 밝은 은색으로 변경) */
        html.dark .text-gray-500, html.dark .text-gray-600, html.dark .text-gray-700, html.dark .text-gray-800 {
            color: #cbd5e1 !important; /* Slate 300 */
        }
        html.dark .text-gray-400 { color: #94a3b8 !important; }
        
        /* 4. 입력창, 버튼, 리스트 아이템 (배경과 명확히 구분되도록 밝게) */
        html.dark input, html.dark textarea, html.dark select, html.dark .world-select-btn, html.dark .bg-gray-200 {
            background-color: #334155 !important; /* Slate 700 */
            color: #fff !important; 
            border-color: #475569 !important;
        }
        
        /* 5. 마우스 올렸을 때 (Hover) */
        html.dark .world-select-btn:hover, html.dark .nav-btn:hover, html.dark button:hover {
            background-color: #475569 !important; /* Slate 600 */
            color: #fff !important;
        }


        /* 6. [중요] 선택된 항목 강조 (확실한 포인트 컬러) */
        html.dark .world-select-btn.selected {
            background-color: #4f46e5 !important; /* Indigo 600 */
            border-color: #818cf8 !important;     /* 테두리는 더 밝게 */
            color: #fff !important;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.3) !important;
        }
        html.dark .world-select-btn.selected .text-gray-500 { color: #e0e7ff !important; } /* 선택된 항목 내부 설명글 색상 */


        /* 7. 말풍선 스타일 개선 */
        /* 유저: 선명한 인디고 블루 */
        html.dark .msg-wrapper.user .novel-text {
            background-color: #4338ca !important; 
            color: #e0e7ff !important; 
            border-left-color: #818cf8 !important;
        }
        /* AI: 배경색 없이 글자만 하얗게 (또는 아주 연한 배경) */
        html.dark .msg-wrapper.model .novel-text {
            color: #f1f5f9 !important;
        }
        
        /* 8. 기타 요소 (버튼, 뱃지 등) 미세 조정 */
        html.dark .bg-indigo-50 { background-color: #312e81 !important; color: #e0e7ff !important; border-color: #4338ca !important; }
        html.dark .text-indigo-600, html.dark .text-indigo-700 { color: #a5b4fc !important; } /* 너무 어두운 파란 글씨를 밝게 */
        html.dark .text-purple-700 { color: #d8b4fe !important; }
        html.dark .bg-purple-50 { background-color: #581c87 !important; border-color: #6b21a8 !important; }


        /* 모달 백드롭 (뒤에 비치는 배경을 더 어둡게) */
        html.dark .modal-backdrop { background-color: rgba(0, 0, 0, 0.85) !important; }
        html.dark ::-webkit-scrollbar-thumb { background: #475569; }
        html.dark ::-webkit-scrollbar-track { background: #0f172a; }
        /* ▲▲▲ [수정됨] 끝 ▲▲▲ */


/* ▼▼▼ [수정] 다크 모드: AI 생성 태그(키워드) 스타일 ▼▼▼ */


/* 1. 태그 기본 상태 (선택 안됨) */
html.dark .keyword-tag {
    background-color: #334155 !important; /* 어두운 회색 배경 */
    color: #e2e8f0 !important;           /* 밝은 글씨 */
    border-color: #475569 !important;     /* 테두리 */
}


/* 2. 태그 마우스 올렸을 때 (Hover) */
html.dark .keyword-tag:hover {
    background-color: #475569 !important; /* 살짝 더 밝게 */
}


/* 3. 태그 선택됨 (Active) - 확실한 강조 색상 */
html.dark .keyword-tag.active {
    background-color: #4f46e5 !important; /* 인디고 블루 (강조) */
    color: #ffffff !important;            /* 흰색 글씨 */
    border-color: #818cf8 !important;     /* 밝은 테두리 */
    box-shadow: 0 0 5px rgba(99, 102, 241, 0.5) !important; /* 은은한 광원 효과 */
}


/* ▼▼▼ [수정] 선택지(리스트) 줄바꿈 정렬 개선 ▼▼▼ */


/* 1. 리스트 마커(숫자)를 텍스트 영역 밖으로 뺌 */
.novel-text ol, .novel-text ul {
    list-style-position: outside !important; 
    padding-left: 1.8rem !important; /* 숫자 들어갈 공간 확보 */
    margin-left: 0.2rem !important;
}


/* 2. 리스트 내부 간격 조정 */
.novel-text li {
    margin-bottom: 0.4rem !important; /* 항목 간 간격 넓힘 (가독성) */
    padding-left: 0.3rem !important;  /* 텍스트와 숫자 사이 간격 */
}


/* ▼▼▼ [수정] 선택지(리스트) 줄바꿈 정렬 개선 ▼▼▼ */
.novel-text li p {
    display: block !important; 
    margin: 0 !important;
}


/* ▼▼▼ [신규] 1단계: 오른쪽 사이드바 리팩토링 스타일 ▼▼▼ */
.right-tab-btn {
    flex: 1;
    text-align: center;
    padding: 0.75rem 0;
    font-size: 0.85rem;
    font-weight: 600;
    color: #64748b;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
}
.right-tab-btn:hover { background-color: #f8fafc; color: #475569; }
.right-tab-btn.active {
    color: #4f46e5;
    border-bottom-color: #4f46e5;
    background-color: #fff;
}
html.dark .right-tab-btn { color: #94a3b8; }
html.dark .right-tab-btn:hover { background-color: #1e293b; color: #cbd5e1; }
html.dark .right-tab-btn.active { color: #818cf8; border-bottom-color: #818cf8; background-color: #0f172a; }


.setting-group-label {
    font-size: 0.75rem;
    font-weight: 700;
    color: #64748b;
    margin-bottom: 0.25rem;
    display: block;
}
html.dark .setting-group-label { color: #94a3b8; }


.sidebar-select {
    width: 100%;
    padding: 0.4rem;
    font-size: 0.85rem;
    border: 1px solid #cbd5e1;
    border-radius: 0.375rem;
    background-color: white;
    color: #334155;
}
html.dark .sidebar-select {
    background-color: #334155;
    border-color: #475569;
    color: #f1f5f9;
}
/* ▲▲▲ 1단계 스타일 끝 ▲▲▲ */


/* ▼▼▼ [수정됨] 2단계: 안전한 리사이즈 핸들 스타일 ▼▼▼ */


/* 1. 리사이즈 핸들 디자인 */
.resize-grip {
    height: 12px; /* 높이 약간 줄임 (공간 절약) */
    background-color: #f1f5f9;
    border-top: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: row-resize;
    touch-action: none; /* 터치 스크롤 방지 */
    user-select: none;
    flex-shrink: 0; /* 높이 줄어듦 방지 */
}
.resize-grip i {
    width: 30px;
    height: 3px;
    background-color: #cbd5e1;
    border-radius: 2px;
    display: block;
}


html.dark .resize-grip {
    background-color: #1e293b;
    border-color: #334155;
}
html.dark .resize-grip i { background-color: #475569; }


/* 2. 입력창 래퍼 (레이아웃 보호용) */
.resizable-wrapper {
    display: flex;
    flex-direction: column;
    flex: 1;         /* 남은 공간 차지 */
    min-width: 0;    /* 플렉스 박스 넘침 방지 */
    position: relative;
}


/* 3. 사이드바 터치 영역 확장 (가상 요소) */
#sidebar::after, #right-sidebar::before {
    content: ''; position: absolute; top: 0; width: 20px; height: 100%; z-index: 50;
    pointer-events: none; /* 드래그 구현 전까지는 클릭 통과 */
}
#sidebar::after { right: -10px; }
#right-sidebar::before { left: -10px; }


/* ▼▼▼ [필수] 리사이즈 핸들 스타일 (없으면 style 태그 맨 아래에 추가하세요) ▼▼▼ */
.resize-grip {
    height: 12px;
    background-color: #f1f5f9;
    border-top: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: row-resize;
    touch-action: none;
    user-select: none;
    flex-shrink: 0;
}
.resize-grip i { width: 30px; height: 3px; background-color: #cbd5e1; border-radius: 2px; display: block; }
html.dark .resize-grip { background-color: #1e293b; border-color: #334155; }
html.dark .resize-grip i { background-color: #475569; }


.resizable-wrapper {
    display: flex; flex-direction: column; flex: 1; min-width: 0; position: relative;
}


    </style>
</head>


<body class="bg-gray-100 overflow-hidden flex h-dvh">
    <div id="dim-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-[55] hidden md:hidden" onclick="closeAllSidebars()"></div>


    <aside id="sidebar" class="bg-white border-r border-gray-200 flex flex-col h-full shadow-xl">
        <div class="p-4 border-b border-gray-100 bg-indigo-600 text-white flex justify-between items-center flex-shrink-0">
            <h1 class="font-bold text-lg"><i class="fa-solid fa-book-open mr-2"></i>E.No.S v2.51</h1>
            <button onclick="closeAllSidebars()" class="text-white md:hidden"><i class="fa-solid fa-times text-xl"></i></button>
        </div>
        <div class="flex text-sm border-b border-gray-200 bg-gray-50 flex-shrink-0">
            <!-- 탭 명칭 변경: 채팅방 -> 라이브러리 -->
            <button onclick="switchNav('chats')" id="nav-chats" class="nav-btn active flex-1 py-3 font-medium text-gray-500 hover:text-indigo-600 transition">라이브러리</button>
            <button onclick="switchNav('worlds')" id="nav-worlds" class="nav-btn flex-1 py-3 font-medium text-gray-500 hover:text-indigo-600 transition">배경</button>
        </div>
        <div id="sidebar-content" class="flex-1 overflow-y-auto bg-white relative">
            <div id="panel-chats" class="p-2 space-y-2"></div>
            <div id="panel-worlds" class="p-2 space-y-2 hidden"></div>
        </div>
        <div id="creation-buttons" class="p-3 border-t border-gray-100 bg-gray-50 flex flex-col gap-2 flex-shrink-0 relative">
            <button id="external-char-create-btn" onclick="openAiGeneratorModal('creative_char')" class="hidden w-full py-2 bg-purple-600 text-white rounded-lg shadow hover:bg-purple-700 text-sm font-bold flex items-center justify-center gap-2">
                <i class="fa-solid fa-search"></i> 창작물 캐릭터(검색)
            </button>
             <button id="external-user-create-btn" onclick="openAiGeneratorModal('creative_user')" class="hidden w-full py-2 bg-purple-600 text-white rounded-lg shadow hover:bg-purple-700 text-sm font-bold flex items-center justify-center gap-2">
                <i class="fa-solid fa-search"></i> 창작물 유저(검색)
            </button>
             <button id="external-world-create-btn" onclick="openAiGeneratorModal('creative_world')" class="hidden w-full py-2 bg-purple-600 text-white rounded-lg shadow hover:bg-purple-700 text-sm font-bold flex items-center justify-center gap-2">
                <i class="fa-solid fa-search"></i> 창작물 배경
            </button>
            
            <button id="ai-create-btn" class="w-full py-2 bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 text-sm font-bold flex items-center justify-center gap-2">
                <i class="fa-solid fa-wand-magic-sparkles"></i> AI로 생성
            </button>
            <button id="manual-create-btn" class="w-full py-2 bg-white border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-100 text-sm font-bold flex items-center justify-center gap-2">
                 <i class="fa-solid fa-pen-ruler"></i> 직접 입력
            </button>
             <button onclick="openCoreModal()" class="w-full mt-2 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 text-sm">
                <i class="fa-solid fa-cogs"></i> 설정
            </button>
        </div>
    </aside>


    <main id="main-content" class="flex-1 flex flex-col relative w-full bg-gray-50 overflow-hidden">
        <header class="h-16 flex items-center justify-between px-3 md:px-4 border-b border-gray-200 bg-white z-20 shadow-sm flex-shrink-0">
            <div class="flex items-center gap-2 md:gap-3 overflow-hidden flex-1">
                <button onclick="toggleSidebar()" class="text-gray-600 mr-1 p-2 rounded hover:bg-gray-100 z-50 relative"><i class="fa-solid fa-bars text-xl"></i></button>
<div class="flex flex-col overflow-hidden w-full">
    <div class="flex items-center gap-2 cursor-pointer group" onclick="editChatTitle()" title="클릭하여 제목 수정">
        <h2 id="header-title" class="font-bold text-gray-800 truncate group-hover:text-indigo-600 transition">E.No.S v2.51</h2>
        <i class="fa-solid fa-pen text-xs text-gray-400 group-hover:text-indigo-600 transition flex-shrink-0"></i>
    </div>


    <div id="header-info" class="text-xs text-gray-500 truncate hidden items-center gap-2 md:gap-3">
        <span id="info-world"><i class="fa-solid fa-globe"></i> -</span>
        <span id="model-display" class="font-medium text-indigo-500 text-xs md:text-sm"></span>
    </div>
</div>
            </div>
            
            <button onclick="toggleRightSidebar()" class="text-gray-600 w-10 h-10 flex items-center justify-center hover:bg-gray-100 rounded-full transition" title="도구 모음"><i class="fa-solid fa-toolbox text-xl"></i></button>
        </header>


        <div id="content-area" class="flex-1 overflow-y-auto p-4 md:p-6 transition-all duration-300 min-h-0 bg-white">
            <div id="empty-state" class="flex flex-col items-center justify-center h-full text-gray-400 space-y-4">
                <i class="fa-solid fa-feather text-6xl text-gray-200"></i>
                <p>좌측 메뉴에서 새로운 이야기를 시작하세요.</p>
            </div>
        </div>


<footer id="input-area" class="pt-2 px-4 bg-white border-t border-gray-200 hidden flex-col flex-shrink-0 z-50">
            <form id="chat-form" onsubmit="event.preventDefault(); handleFormSubmit();" class="max-w-4xl mx-auto relative w-full">
                
<div id="macro-popup" class="absolute bottom-full left-0 mb-2 bg-white border border-gray-200 shadow-lg rounded-xl p-2 flex flex-wrap gap-2 hidden w-full z-50">
</div>


                <div class="flex gap-2 items-end">
                    <button type="button" onclick="toggleMacroPopup()" class="w-10 h-10 md:w-12 md:h-12 flex-shrink-0 rounded-full bg-gray-200 text-gray-600 hover:bg-gray-300 flex items-center justify-center transition">
                        <i class="fa-solid fa-plus"></i>
                    </button>


                    <textarea id="msg-input" rows="1" placeholder="메시지 입력" class="flex-1 bg-gray-100 text-gray-800 rounded-2xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none shadow-inner" style="max-height: 150px;"></textarea>
                    
                    <button type="submit" id="send-btn" class="bg-indigo-600 text-white rounded-full w-10 h-10 md:w-12 md:h-12 flex-shrink-0 flex items-center justify-center hover:bg-indigo-700 shadow-lg transition-transform active:scale-95 transition-colors duration-200">
                        <i class="fa-solid fa-paper-plane"></i>
                    </button>
                </div>
            </form>
        </footer>
    </main>


    <!-- 오른쪽 사이드바 (도구 모음 + 로어북) -->
    <aside id="right-sidebar" class="bg-white border-l border-gray-200 flex flex-col h-full shadow-xl closed">
        <div class="p-4 border-b border-gray-200 bg-slate-800 text-white flex justify-between items-center h-16 flex-shrink-0">
            <h2 class="font-bold text-lg"><i class="fa-solid fa-toolbox mr-2"></i>스튜디오 도구</h2>
            <button onclick="toggleRightSidebar()" class="text-gray-300 hover:text-white"><i class="fa-solid fa-times text-xl"></i></button>
        </div>
        <div id="right-sidebar-content" class="flex-1 overflow-y-auto p-3 space-y-4"></div>
    </aside>


    <div id="modal-container" class="fixed inset-0 z-[70] hidden">
        <div id="ai-generator-modal" class="absolute inset-0 flex items-center justify-center p-4 modal-backdrop hidden" onclick="closeModal('ai-generator-modal')">
            <div class="bg-gray-100 rounded-xl w-full max-w-2xl h-[90vh] flex flex-col shadow-2xl relative" onclick="event.stopPropagation()">
                 <div id="modal-loading-overlay-ai" class="absolute inset-0 bg-white/70 z-10 hidden items-center justify-center flex-col space-y-2 rounded-xl">
                    <i class="fa-solid fa-spinner fa-spin text-4xl text-indigo-600"></i>
                    <span class="text-sm font-medium text-gray-700">AI가 작업을 진행 중입니다...</span>
                    <span id="ai-progress-time" class="text-xs text-indigo-600 font-bold hidden bg-indigo-50 px-3 py-1 rounded-full">0초 경과</span>
                    
                    <button onclick="cancelGeneration()" class="mt-4 px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-bold shadow transition flex items-center gap-2">
                        <i class="fa-solid fa-stop"></i> 중단하기
                    </button>


                    <span id="ai-retry-msg" class="text-xs text-red-500 hidden">트래픽 과부하 감지. 1초 후 재시도합니다...</span>
                    <span id="ai-error-msg" class="text-xs text-red-600 font-bold mt-2 hidden"></span>
                </div>
                <div class="p-4 border-b flex justify-between items-center bg-white rounded-t-xl relative">
                    <div class="flex items-center gap-3">
                        <h3 class="font-bold text-lg text-gray-800"><i class="fa-solid fa-wand-magic-sparkles mr-2 text-indigo-500"></i>AI로 생성하기</h3>
                        <button id="btn-random-gen" onclick="randomizeTab()" class="px-3 py-1 bg-purple-100 text-purple-700 rounded text-xs font-bold hover:bg-purple-200 hidden transition">
                            <i class="fa-solid fa-dice mr-1"></i>랜덤 설정 (현재 탭)
                        </button>
                    </div>
                    <button onclick="closeModal('ai-generator-modal')" class="text-gray-500 hover:text-black p-2"><i class="fa-solid fa-times text-xl"></i></button>
                </div>
                <div id="ai-generator-tabs" class="flex border-b bg-gray-50 hidden"></div> 
                <div id="ai-generator-body" class="flex-1 overflow-y-auto p-6"></div>
                <div class="p-4 border-t bg-gray-50 flex justify-end rounded-b-xl">
                    <button onclick="handleGenerateClick()" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold shadow">
                        <i class="fa-solid fa-dice mr-2"></i>생성하기
                    </button>
                </div>
            </div>
        </div>


<div id="editor-modal" class="absolute inset-0 flex items-center justify-center p-4 modal-backdrop hidden" onclick="tryCloseModal('editor-modal')">
            <div class="bg-white rounded-xl w-full max-w-3xl h-[90vh] flex flex-col shadow-2xl relative" onclick="event.stopPropagation()">
                <div id="modal-loading-overlay-details" class="absolute inset-0 bg-white/70 z-20 hidden items-center justify-center flex-col space-y-2 rounded-xl">
                    <i class="fa-solid fa-spinner fa-spin text-4xl text-indigo-600"></i>
                    <span class="text-sm font-medium text-gray-700">AI가 설정/상세 정보를 채우는 중...</span>
                    <button onclick="cancelDetailGeneration()" class="mt-4 px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-bold shadow transition flex items-center gap-2">
                        <i class="fa-solid fa-stop"></i> 중단하기
                    </button>
                </div>
                <div class="p-4 border-b border-gray-200 bg-gray-50 rounded-t-xl flex justify-between items-center">
                    <h3 id="modal-title" class="font-bold text-lg text-gray-800">설정</h3>
                    <div class="flex gap-2 items-center">
                        <button id="btn-gen-details" onclick="generateDetails()" class="px-3 py-1 bg-yellow-100 text-yellow-700 rounded-lg text-xs font-bold hover:bg-yellow-200 border border-yellow-300 hidden">
                            <i class="fa-solid fa-wand-magic-sparkles mr-1"></i> AI로 설정 채우기
                        </button>
                        <button onclick="closeModal('editor-modal')" class="text-gray-500 hover:text-black p-2"><i class="fa-solid fa-times text-xl"></i></button>
                    </div>
                </div>
                <div id="modal-body" class="flex-1 overflow-y-auto p-6"></div>
                <div class="p-4 border-t border-gray-200 bg-gray-50 flex justify-between items-center gap-2 rounded-b-xl">
                    <button id="modal-delete-btn" class="px-4 py-2 text-red-500 hover:bg-red-50 rounded-lg text-sm font-medium hidden">삭제</button>
                    <button id="modal-save-btn" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold shadow">저장하기</button>
                </div>
            </div>
        </div>


<div id="memory-modal" class="absolute inset-0 flex items-center justify-center p-4 modal-backdrop hidden" onclick="tryCloseModal('memory-modal')">
    <div class="bg-white rounded-xl w-full max-w-lg shadow-2xl flex flex-col max-h-[90vh] relative" onclick="event.stopPropagation()">
        
        <div id="modal-loading-overlay-memory" class="absolute inset-0 bg-white/80 z-20 hidden items-center justify-center flex-col space-y-3 rounded-xl">
            <i class="fa-solid fa-spinner fa-spin text-4xl text-indigo-600"></i>
            <span class="text-sm font-bold text-gray-700">🧠 AI가 기억을 요약/재구성 중입니다...</span>
        </div>


        <div class="p-4 border-b border-gray-200 bg-gray-50 flex justify-between items-center rounded-t-xl">
                    <h3 class="font-bold text-lg text-gray-800"><i class="fa-solid fa-brain mr-2 text-indigo-500"></i>장기 기억</h3>
                    
                    <div class="flex gap-2 items-center">
                        <button onclick="generateAutoSummary()" class="px-3 py-1.5 bg-yellow-100 text-yellow-700 text-xs font-bold rounded-lg hover:bg-yellow-200 transition border border-yellow-300 flex items-center shadow-sm">
                            <i class="fa-solid fa-wand-magic-sparkles mr-1.5"></i>AI 자동 요약
                        </button>


                        <button onclick="closeModal('memory-modal')" class="w-8 h-8 flex items-center justify-center rounded-full text-gray-400 hover:text-gray-600 hover:bg-gray-200 transition">
                            <i class="fa-solid fa-times text-lg"></i>
                        </button>
                    </div>
                </div>


                <div class="p-5 flex-1 overflow-y-auto">
                    <textarea id="memory-input" class="w-full p-3 border rounded-lg h-64 resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="여기에 작성된 내용은 AI가 영구적으로 기억합니다."></textarea>
                </div>
                
                <div class="p-4 border-t border-gray-200 bg-gray-50 flex justify-end rounded-b-xl">
                    <button onclick="saveMemory()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition shadow">저장</button>
                </div>
            </div>
        </div>




        <!-- 전역 설정 모달 (Core Modal) -->
        <div id="core-modal" class="absolute inset-0 flex items-center justify-center p-0 md:p-4 modal-backdrop hidden" onclick="closeModal('core-modal')">
            <!-- 모바일에서는 h-full, PC에서는 h-[90vh] 및 둥근 모서리 적용 -->
            <div class="bg-white rounded-xl w-full max-w-4xl h-full flex flex-col shadow-2xl md:h-[90vh] md:rounded-xl" onclick="event.stopPropagation()">
                <div class="p-4 border-b border-gray-200 flex justify-between items-center"><h3 class="font-bold text-lg">전역 설정</h3><button onclick="closeModal('core-modal')" class="text-gray-500 hover:text-black"><i class="fa-solid fa-times text-xl"></i></button></div>
                <div class="flex-1 flex overflow-y-auto flex-col md:flex-row">
                    <!-- 모바일용 탭 선택 드롭다운 -->
                    <div class="md:hidden p-4 border-b border-gray-200 bg-gray-50 flex-shrink-0">
                        <select id="core-tab-select-mobile" class="w-full p-2 border rounded-lg bg-white" onchange="switchCoreTab(this.value)">
                            <option value="api">API 및 모델</option>
                            <option value="novel">소설 상세설정</option>
                            <option value="view">화면 설정</option>
                            <option value="core">AI 핵심 지침</option>
                            <option value="dic">용어/표현 지침</option>
                            <option value="macro">단축 문구</option>
                            <option value="data">데이터 관리</option>
                        </select>
                    </div>


                    <!-- PC용 탭 사이드바 -->
                    <div id="core-modal-nav-desktop" class="w-full md:w-1/3 border-b md:border-b-0 md:border-r border-gray-200 bg-gray-50 hidden md:block flex-shrink-0">
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('api')">API 및 모델</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('novel')">소설 상세설정</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('view')">화면 설정</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('core')">AI 핵심 지침</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('dic')">용어/표현 지침</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('macro')">단축 문구</button>
                        <button class="block w-full text-left p-4 font-medium border-b hover:bg-gray-100" onclick="switchCoreTab('data')">데이터 관리</button>
                    </div>
                    
<div class="w-full md:w-2/3 flex-1 overflow-y-auto p-6">
 <div id="core-tab-api" class="core-tab-content space-y-4">
    <div>
        <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">AI 공급자 (Provider)</label>
        <select id="core-provider-select" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100" onchange="toggleProviderSettings()">
            <option value="gemini">Google Gemini (기본)</option>
            <option value="openai">OpenAI Compatible (OpenRouter, Local 등)</option>
        </select>
    </div>

    <div id="settings-group-gemini" class="space-y-4 border p-3 rounded-lg bg-indigo-50 dark:bg-slate-800 dark:border-slate-700">
        <h5 class="font-bold text-indigo-700 dark:text-indigo-400 text-xs uppercase"><i class="fa-brands fa-google mr-1"></i>Gemini 설정</h5>
        <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Gemini API Key</label>
            <div class="relative">
                <input type="password" id="core-api-key" class="w-full p-2 border rounded-lg pr-10 bg-white dark:bg-slate-700 dark:text-white" placeholder="Google API Key 입력">
                <button type="button" onclick="toggleApiKeyVisibility()" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-indigo-600">
                    <i id="api-key-icon" class="fa-solid fa-eye"></i>
                </button>
            </div>
        </div>
        <p class="text-xs text-gray-500 mt-2 font-bold text-indigo-600">현재 적용 모델: <span id="current-model-display"></span></p>
        <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">모델 선택</label>
            <select id="core-model-select" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:text-white">
                <option value="gemini-3-pro-preview">Gemini 3 Pro (최신/최고성능)</option>
                <option value="gemini-3-flash-preview">Gemini 3 Flash (최신/빠름)</option>
                <option value="gemini-2.5-pro">Gemini 2.5 Pro (안정적)</option>
                <option value="gemini-2.5-flash">Gemini 2.5 Flash (가성비)</option>
            </select>
        </div>
    </div>

    <div id="settings-group-openai" class="space-y-4 border p-3 rounded-lg bg-green-50 dark:bg-slate-800 dark:border-slate-700 hidden">
        <h5 class="font-bold text-green-700 dark:text-green-400 text-xs uppercase"><i class="fa-solid fa-network-wired mr-1"></i>OpenAI Compatible 설정</h5>
        <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Base URL</label>
            <input type="text" id="core-custom-url" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:text-white" placeholder="예: https://openrouter.ai/api/v1">
            <p class="text-[10px] text-gray-500 mt-1">* 주소 끝에 /chat/completions는 자동으로 붙습니다.</p>
        </div>
<div>
    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">API Key</label>
    <div class="relative">
        <input type="password" id="core-custom-key" class="w-full p-2 border rounded-lg pr-10 bg-white dark:bg-slate-700 dark:text-white" placeholder="sk-...">
        <button type="button" onclick="toggleCustomApiKeyVisibility()" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500 hover:text-green-600">
            <i id="custom-api-key-icon" class="fa-solid fa-eye"></i>
        </button>
    </div>
</div>
        <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Model ID</label>
            <input type="text" id="core-custom-model" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:text-white" placeholder="예: liquid/lfm-40b, deepseek/deepseek-r1">
        </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-2">
        <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">출력 속도</label>
            <select id="core-speed-select" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:text-white">
                <option value="15">빠름 (15ms)</option>
                <option value="30">보통 (30ms)</option>
            </select>
        </div>
    </div>
    
    <div class="mt-3">
        <label class="block text-sm font-medium text-gray-700 mb-1">최대 출력 길이 (토큰)</label>
        <div class="flex items-center gap-2">
            <span class="text-xs text-gray-500 w-8">2k</span>
            <input type="range" id="core-max-token-slider" min="2000" max="8000" step="1000" class="flex-1 accent-indigo-600 cursor-pointer">
            <span class="text-xs text-gray-500 w-8">8k</span>
        </div>
        <div class="text-right text-sm text-indigo-600 font-bold mt-1">
            현재 설정: <span id="core-max-token-val">2000</span> 토큰
        </div>
    </div>

    <div class="flex items-center justify-between p-3 bg-red-50 border border-red-100 rounded-lg mt-2">
        <span class="text-sm font-bold text-red-700">안전 필터 끄기 (Uncensored)</span>
        <input type="checkbox" id="core-safety-toggle" class="w-5 h-5 text-red-600 focus:ring-red-500 border-gray-300 rounded">
    </div>
</div>



    <div id="core-tab-novel" class="core-tab-content hidden space-y-4">
        <h4 class="font-bold text-gray-700 mb-2">소설 연출 상세 지침</h4>
        <div>
            <label class="block text-sm font-bold text-gray-700 mb-1">서술 시점 (Point of View)</label>
            <select id="core-novel-point" class="w-full p-2 border rounded-lg bg-white">
                <option value="3인칭 제한적 시점 (추천)">3인칭 제한적 시점 (추천: 주인공 내면 묘사 위주)</option>
                <option value="3인칭 제한적 (히로인 내면)">3인칭 제한적 (히로인 내면 묘사 위주)</option>
                <option value="1인칭 주인공 시점">1인칭 주인공 시점 (나는...)</option>
                <option value="3인칭 관찰자 시점">3인칭 관찰자 시점 (영화적/건조함)</option>
                <option value="3인칭 전지적 작가 시점">3인칭 전지적 작가 시점 (모든 것 파악)</option>
            </select>
        </div>


        <div>
            <label class="block text-sm font-bold text-gray-700 mb-1">문체 스타일</label>
            <select id="core-novel-style" class="w-full p-2 border rounded-lg bg-white">
                <option value="웹소설체">웹소설체 (가독성 높음/적당한 묘사)</option>
                <option value="간결/건조체">간결/건조체 (짧은 문장/하드보일드)</option>
                <option value="만연/화려체">만연/화려체 (풍부한 묘사/감성적)</option>
            </select>
        </div>


        <div>
            <label class="block text-sm font-bold text-gray-700 mb-1">서술/대화 비중</label>
            <select id="core-novel-ratio" class="w-full p-2 border rounded-lg bg-white">
                <option value="밸런스형">밸런스형 (대화 50 : 지문 50)</option>
                <option value="여자 발언 위주">여자 발언 위주</option>
                <option value="대화 중심">대화 중심 (티키타카 위주)</option>
                <option value="지문/묘사 중심">지문/묘사 중심 (상황 설명 위주)</option>
            </select>
        </div>


        <div class="mt-4 p-3 bg-red-50 border border-red-100 rounded-lg">
            <div class="flex justify-between items-center mb-2">
                <label class="font-bold text-red-800 text-sm"><i class="fa-solid fa-bolt mr-1"></i>돌발 이벤트 (Auto-Event)</label>
                <div class="flex items-center gap-2">
                    <span class="text-xs text-red-600 font-bold" id="event-chance-display">10%</span>
                    <input type="range" id="auto-event-chance" min="0" max="50" step="5" value="10" class="w-24 accent-red-600 cursor-pointer" oninput="document.getElementById('event-chance-display').innerText = this.value + '%'">
                    <input type="checkbox" id="auto-event-toggle" class="w-5 h-5 text-red-600 rounded focus:ring-red-500 cursor-pointer">
                </div>
            </div>
            <p class="text-xs text-red-700 opacity-80 leading-snug">
                대화 진행 중 AI가 무작위로 '위기'나 '신체 변수'를 발생시켜 상황을 비틉니다.<br>
                (0%로 설정하거나 체크를 해제하면 작동하지 않습니다.)
            </p>
        </div>
    </div>


    <div id="core-tab-view" class="core-tab-content hidden space-y-4">
        <h4 class="font-bold text-gray-700">텍스트/화면 설정</h4>


        <div class="flex items-center justify-between p-3 bg-gray-100 rounded-lg border">
            <span class="font-bold text-gray-700"><i class="fa-solid fa-moon mr-2"></i>다크 모드 (야간용)</span>
            <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="dark-mode-toggle" class="sr-only peer" onchange="toggleDarkMode()">
                <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
            </label>
        </div>


        <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">글자 크기 조절</label>
            <input type="range" id="font-size-slider" min="14" max="24" step="1" class="w-full accent-indigo-600">
            <div class="text-right text-sm text-gray-500 mt-1">현재: <span id="font-size-val">1.1rem</span></div>
        </div>
        <div class="p-4 bg-gray-100 rounded-lg text-gray-800 border" style="min-height: 100px;">
            <p class="novel-text" id="font-preview-text">
                이 텍스트는 미리보기입니다.<br>
                폰트 크기를 조절하면 이 부분과<br>
                채팅창의 텍스트 크기가 변경됩니다.
            </p>
        </div>
    </div>


    <div id="core-tab-core" class="core-tab-content hidden space-y-3">
        <div class="mb-2 text-xs text-gray-500">체크박스를 해제하면 해당 규칙은 AI에게 전달되지 않습니다.</div>
        <div id="core-rules-list" class="space-y-3"></div>
        <button onclick="addEntryUI('core-rules-list', {title:'새 규칙',content:'',enabled:true})" class="w-full py-2 bg-indigo-50 text-indigo-600 font-bold rounded">+ 규칙 추가</button>
    </div>


    <div id="core-tab-dic" class="core-tab-content hidden space-y-3">
        <div id="core-dic-list" class="space-y-3"></div>
        <button onclick="addEntryUI('core-dic-list', {title:'새 용어',content:'',enabled:true})" class="w-full py-2 bg-indigo-50 text-indigo-600 font-bold rounded">+ 용어 추가</button>
    </div>


    <div id="core-tab-data" class="core-tab-content hidden space-y-4">
        <button onclick="backupData()" class="w-full py-2 bg-gray-100 hover:bg-gray-200 rounded">전체 백업 (다운로드)</button>
        <button onclick="loadBackup()" class="w-full py-2 bg-gray-100 hover:bg-gray-200 rounded">전체 복구 (불러오기)</button>
    </div>


    <div id="core-tab-macro" class="core-tab-content hidden space-y-4">
        <div class="bg-indigo-50 p-3 rounded text-sm text-indigo-700 mb-2">
            <i class="fa-solid fa-info-circle mr-1"></i> 채팅 입력창 왼쪽의 <b>(+) 버튼</b>을 눌렀을 때 나오는 단축키들을 설정합니다.
        </div>
        <div id="macro-list" class="space-y-2 max-h-[60vh] overflow-y-auto pr-1"></div>
        <button onclick="addMacroUI()" class="w-full py-2 bg-indigo-100 text-indigo-600 font-bold rounded hover:bg-indigo-200">+ 새 단축 문구 추가</button>
    </div>
</div>


</div>
                <div class="p-4 border-t flex justify-end"><button onclick="saveCoreSettings()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg font-bold">저장</button></div>
            </div>
        </div>


        
<div id="textarea-editor-modal" class="absolute inset-0 flex items-center justify-center p-4 modal-backdrop hidden" onclick="tryCloseModal('textarea-editor-modal')">
             <div class="bg-white rounded-xl w-full max-w-4xl h-[90vh] flex flex-col shadow-2xl" onclick="event.stopPropagation()">
                <div class="p-4 border-b border-gray-200 flex justify-between items-center">
                    <h3 class="font-bold text-lg">전체 화면 편집</h3>
                    <button onclick="closeModal('textarea-editor-modal')" class="text-gray-500 hover:text-black"><i class="fa-solid fa-times text-xl"></i></button>
                </div>
                <div class="flex-1 p-2">
                    <textarea id="modal-textarea-input" class="w-full h-full p-3 border rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500 font-mono text-sm"></textarea>
                </div>
                <div class="p-4 border-t border-gray-200 bg-gray-50 flex justify-end">
                    <button onclick="saveAndCloseTextareaEditor()" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-bold shadow">적용하고 닫기</button>
                </div>
            </div>
        </div>


        <div id="session-modal" class="absolute inset-0 flex items-center justify-center p-4 modal-backdrop hidden" onclick="closeModal('session-modal')">
            <div class="bg-white rounded-xl w-full max-w-4xl shadow-2xl flex flex-col max-h-[90vh]" onclick="event.stopPropagation()">
                <div class="p-5 border-b border-gray-200"><h3 class="font-bold text-lg" id="session-modal-title">이야기 설정</h3></div>
                <div class="p-5 flex-1 overflow-hidden flex flex-col md:flex-row gap-6">
                    <div id="session-world-area" class="md:w-1/2 flex flex-col overflow-hidden">
                         <label class="block text-sm font-bold text-gray-700 mb-2"><i class="fa-solid fa-globe mr-1"></i>배경 선택</label>
                         <div id="world-selection-list" class="flex-1 overflow-y-auto space-y-2 pr-2 border p-2 rounded-lg bg-gray-50"></div>
                         <div id="world-fixed-display" class="hidden p-4 bg-indigo-50 rounded-lg border border-indigo-200 text-indigo-700 font-bold"></div>
                    </div>
                    <div class="md:w-1/2 flex flex-col">
                        <label class="block text-sm font-bold text-gray-700 mb-2"><i class="fa-solid fa-users mr-1"></i>참여 캐릭터</label>
                        <div id="session-chars" class="h-64 overflow-y-auto border p-3 rounded-lg bg-gray-50 space-y-2">
                            <div class="text-gray-400 text-center text-sm mt-10">좌측에서 배경을 선택하세요.</div>
                        </div>
                    </div>
                </div>
                <div class="p-4 border-t flex justify-end bg-gray-50 rounded-b-xl">
                    <button onclick="closeModal('session-modal')" class="mr-2 px-4 py-2 text-gray-500 font-medium hover:text-gray-800">취소</button>
                    <button onclick="saveSessionSettings()" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold shadow transition">확인 및 시작</button>
                </div>
            </div>
        </div>
    </div> 


    <script>


// ▼▼▼ [수정됨] 2단계: 안전한 래퍼 방식 리사이즈 함수 ▼▼▼


function makeResizable(textarea) {
    if (!textarea || textarea.parentElement.classList.contains('resizable-wrapper')) return;


    // 1. 보호용 래퍼(Wrapper) 생성
    const wrapper = document.createElement('div');
    wrapper.className = 'resizable-wrapper';
    
    // 2. 래퍼를 기존 textarea 위치에 삽입
    textarea.parentNode.insertBefore(wrapper, textarea);
    
    // 3. textarea를 래퍼 안으로 이동
    wrapper.appendChild(textarea);


    // 4. 핸들(Grip) 생성 및 래퍼 안에 추가
    const grip = document.createElement('div');
    grip.className = 'resize-grip';
    grip.innerHTML = '<i></i>'; // 시각적 바
    wrapper.appendChild(grip);


    // 5. 드래그 로직 (모바일/PC 공용)
    let startY, startHeight;


    const onStart = (e) => {
        // e.preventDefault(); // 입력창 포커스 해제 방지를 위해 제거
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        startHeight = parseInt(window.getComputedStyle(textarea).height, 10);
        
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('touchend', onEnd);
    };


    const onMove = (e) => {
        if(e.touches) e.preventDefault(); // 스크롤 방지
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const delta = clientY - startY;
        
        // 최소 40px ~ 최대 50vh 제한
        const newH = Math.min(Math.max(40, startHeight + delta), window.innerHeight * 0.5);
        textarea.style.height = `${newH}px`;
        textarea.style.maxHeight = 'none'; // 기존 max-height 무시
    };


    const onEnd = () => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onEnd);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', onEnd);
    };


    grip.addEventListener('mousedown', onStart);
    grip.addEventListener('touchstart', onStart, { passive: false });
}




// 5. 책갈피 토글
function toggleBookmark(index) {
    const chat = DB.chats.find(c => c.id === AppState.sessionId);
    if (chat) {
        // bookmarked 속성 토글
        chat.history[index].bookmarked = !chat.history[index].bookmarked;
        saveData();
        loadSession(AppState.sessionId); // 아이콘 상태 업데이트를 위해 리로드
        
        if (chat.history[index].bookmarked) {
            showMessage("🔖 책갈피가 설정되었습니다.");
        }
    }
}


// 책갈피 이름 수정 기능
function editBookmarkName(index) {
    const chat = DB.chats.find(c => c.id === AppState.sessionId);
    if (!chat) return;


    const msg = chat.history[index];
    // 기존 이름이 있으면 가져오고 없으면 빈 값
    const currentName = msg.bookmarkName || ""; 
    
    const newName = prompt("책갈피의 이름을 입력하세요 (비워두면 숨김):", currentName);
    
    // 취소 버튼을 누르지 않은 경우에만 저장
    if (newName !== null) {
        msg.bookmarkName = newName.trim();
        saveData();
        renderRightSidebar(); // 사이드바 갱신
    }
}




// [변경] 책갈피 로드 (기존 세션 유지 + 새 세션 분기 생성)
function loadBookmark(index) {
    const chat = DB.chats.find(c => c.id === AppState.sessionId);
    if (!chat) return;


    // 현재 마지막 시점이라면 굳이 복사할 필요 없음
    if (index === chat.history.length - 1) {
        showMessage("이미 현재 시점입니다.");
        return;
    }


    if (confirm(`🔖 [Turn ${index + 1}] 시점에서 새로운 이야기를 시작하시겠습니까?\n\n- 현재 세션은 그대로 유지됩니다.\n- 선택한 시점까지의 내용을 복사하여 새 세션이 생성됩니다.`)) {
        
        // 1. 현재 세션 객체를 통째로 깊은 복사 (Deep Copy)
        // 참조 관계를 끊기 위해 JSON 변환 방식 사용
        const newChat = JSON.parse(JSON.stringify(chat));
        
        // 2. 새 세션 정보 설정
        newChat.id = Date.now().toString(); // 새 ID 발급
        newChat.title = `${chat.title} (분기 ${index + 1})`; // 제목에 분기 표시
        
        // 3. 히스토리를 해당 시점까지만 남기기 (0 ~ index)
        newChat.history = newChat.history.slice(0, index + 1);
        
        // 4. DB 최상단에 추가
        DB.chats.unshift(newChat);
        
        // 5. 저장 및 화면 전환
        saveData();
        renderSidebar(); // 사이드바 목록 갱신
        loadSession(newChat.id); // 새 세션으로 이동
        
        showMessage("🔀 새로운 타임라인으로 분기되었습니다.");
        
        // 모바일에서는 사이드바 닫기
        if(window.innerWidth < 768) closeAllSidebars();
    }
}


        const aiGeneratorConfig = {
            users: {
                sections: [
                    { title: '성별', singleChoice: true, tags: ['남성', '여성', '중성/무성'], level: 1 },
                    { title: '나이대', singleChoice: true, tags: ['20대', '30대', '40대', '50대 이상', '나이 미상'], level: 1 },
                    { title: '스타일', singleChoice: false, tags: ['미소년', '미청년', '훈남', '평범함', '귀염상', '날카로움', '중후함', '병약함', '듬직함', '양아치', '아저씨', '흑인', '거구', '야성미', '작은 키', '야만족', '펨보이(이성애자)'], level: 1 },
                    { title: '성격', singleChoice: false, tags: ['정의로움', '냉철함', '소심함', '대범함', '능글맞음', '다정함', '광기', '이기적', '껄렁함', '과묵함', '어두운(음침/찐따)', '성욕이 넘치는', '난봉꾼', '사랑꾼', '순진한', '성에 무지함'], level: 2 },
                    { title: '특수 능력', singleChoice: false, tags: ['절대 매력', '독심술', '최면', '투시', '시간 정지', '테크닉 좋음', '성감대 포착', '거근', '정액 무제한', '절륜한 정력'], level: 3 },
                ]
            },
            chars: {
                tabs: [
                    {
                        name: '기본/외형',
                        icon: 'fa-id-card',
                        sections: [
                             { title: '성별', singleChoice: true, tags: ['여성', '남성', '중성/후타나리'], level: 1 },
                             { title: '나이대', singleChoice: true, tags: ['20대', '30대', '40대', '나이 미상'], level: 1 },
                             { title: '직업/역할', singleChoice: false, tags: ['대학생', '아이돌', '회사원', '간호사', '여교사', '가정교사', '과외 선생', '비서', '메이드', '기사', '공주/여왕', '수녀', '성녀', '무녀', '모험가', '마왕', '용사', '노예상인', '암살자', '스트리머', '인간 가축'], level: 2 },
                             { 
                                 title: '종족', 
                                 id: 'race-section',
                                 singleChoice: true, 
                                 tags: ['인간', '엘프', '다크엘프', '드워프', '오크', '고블린', '하플링', '페어리', '안드로이드', '사이보그', '뱀파이어', '서큐버스', '마족', '천사', '타락천사', '용족', '여신', '수인', '오니', '야만족'], 
                                 level: 1 
                             },
                             { 
                                 title: '수인 상세 종류', 
                                 id: 'beast-detail-section',
                                 singleChoice: true, 
                                 tags: ['개 수인', '고양이 수인', '여우 수인', '토끼 수인', '젖소 수인', '말 수인', '표범 수인', '호랑이 수인', '사자 수인', '곰 수인', '돼지 수인', '쥐 수인', '뱀 수인', '새 수인'], 
                                 level: 1,
                                 hidden: true 
                             },
                             { title: '피부색', singleChoice: true, tags: ['하얀 피부', '갈색 피부', '복숭아색 피부', '수영복 자국', '태닝 피부', '창백한 피부'], level: 1 },
                             { title: '체형/몸매', singleChoice: false, tags: ['슬렌더', '운동녀', '육덕', '숏스택', '가는 허리', '터질 듯한 엉덩이', '터질 듯한 허벅지', '모델 체형', '글래머', '아담함', '장신', '골반미녀', '유아 체형'], level: 1 },
                             { title: '가슴 크기', singleChoice: true, tags: ['빈유', '평범', '거유', '폭유'], level: 1 },
                             { title: '눈매', singleChoice: true, tags: ['동그란 눈', '처진 눈', '올라간 눈', '졸린 눈', '삼백안', '죽은 눈', '하트 눈'], level: 1 },
                             { title: '머리칼(헤어)', singleChoice: false, tags: ['긴 생머리', '웨이브', '포니테일', '트윈테일', '땋은 머리', '단발', '숏컷', '금발', '흑발', '은발', '적발', '청발', '분홍 머리'], level: 1 },
                             { title: '스타일', singleChoice: false, tags: ['미소녀', '귀염상', '청순가련', '아이돌 스타일', '냉미녀', '지적임', '도도함', '화려함', '모델 포스', '글래머/섹시', '퇴폐미', '병약함', '음침함', '4차원', '톰보이', '평범녀', '작은 키'], level: 1 },
                             { title: '의상/코스튬', singleChoice: false, tags: ['역바니', '메이드복', '바니걸', '교복', '간호사복', '수영복(비키니)', '란제리 룩', '오피스룩', '드레스', '차이나 드레스', '무녀복', '체육복'], level: 2 },
                             { title: '액세서리', singleChoice: false, tags: ['안경', '머리띠', '리본', '안대', '마스크', '초커', '눈물점', '주근깨', '붕대'], level: 3 },
                             { title: '피어싱', singleChoice: false, tags: ['귀 피어싱', '코/입술 피어싱', '혀 피어싱', '유두 피어싱', '배꼽 피어싱', '음순/클리토리스 피어싱'], level: 3 },
                             { title: '문신', singleChoice: false, tags: ['가슴/쇄골 문신', '등/척추 문신', '팔/다리 문신', '하복부 문신(자궁 문신)', '엉덩이 문신', '유륜 문신', '노예 낙인'], level: 3 },
                        ]
                    },
                    {
                        name: '성격/정신',
                        icon: 'fa-brain',
                        sections: [
                            { title: '주인공과의 관계', singleChoice: false, tags: ['소꿉친구', '첫사랑', '짝사랑', '전여친', '약혼자/썸녀', '여동생', '누나', '엄마', '이모/고모', '딸', '비혈연 가족(의붓)', '학교 선배', '학교 후배', '동급생/친구', '선생님/제자', '직장 상사/부하', '라이벌/앙숙', '갑을 관계(노예/주인)', '유부녀/밀프', '지인의 연인/아내', '초면/남남'], level: 2 },
                            { title: '캐릭터 속성(아키타입)', singleChoice: false, tags: ['재벌 영애(아가씨)', '학교의 아이돌', '반장/모범생', '불량소녀(일진)', '갸루', '히키코모리', '오타쿠/너드', '보이시', '4차원/전파계', '덜렁이', '운동계', '문학소녀', '병약함', '중2병', '외국인/유학생'], level: 2 },
                            { title: '성격 키워드', singleChoice: false, tags: ['애교있는', '츤데레', '얀데레', '쿨데레', '메가데레', '순종적', '헌신적(충견)', '도도함/콧대 높음', '소악마', '천연/백치미', '음침함(찐따)', '소심함', '성욕이 넘치는', '고압적인/여왕', '도발적인', '냉철함/이성적', '다정함/포용력', '싸가지 없음', '과묵함', '철벽녀', '애정결핍', '마이페이스', '망상벽', '순진한', '성에 무지함'], level: 2 },
                            { title: '말투/목소리', singleChoice: false, tags: ['해요체', '하십시오체', '슴다체', '친근한 반말', '하대하는', '갸루 말투', '아가씨 말투', '단답형', '말더듬음', '나른한', '속삭이는', '욕쟁이', '사투리'], level: 2 }
                        ]
                    },
                    {
                        name: '성적 설정',
                        icon: 'fa-heart',
                        sections: [
                            { title: '성적 성향', singleChoice: false, tags: ['경험 없음(처녀)', '경험 많음', '자지 숭배', '흑인 숭배', 'M성향', 'S성향', '봉사 정신', '질내사정 선호', '애널 선호', '딥키스 선호', '색녀/치녀', '노출광', '공중변소', '허접보지', '함몰유두'], level: 3 },
                            { title: '페티시/취향', singleChoice: false, tags: ['냄새 페티시', '굴욕/수치심', '정액 중독', '구속/속박', '도구 사용', '야외 노출', '수면 간', '거울 보기', '더티 토크'], level: 3 },
                            { title: '성감대', singleChoice: true, tags: ['귀', '목덜미', '쇄골', '민감한 가슴/유두', '등/척추', '배/배꼽', '엉덩이', '허벅지 안쪽', '클리토리스/음순', '질 내벽(G스팟)', '항문'], level: 3 },
                            { title: '속옷 스타일', singleChoice: false, tags: ['면 팬티', '노팬티', 'T팬티', '가터벨트', '오픈형 속옷'], level: 3 },
                            { title: '음모/털', singleChoice: true, tags: ['백보지(무모)', '내추럴(수북함)', '깔끔하게 다듬음', '하트 모양', '활주로(I자)', '작은 삼각형', '브라질리언 왁싱'], level: 3 },
                            { title: '특수 상태', singleChoice: false, tags: ['임신 중', '배란기', '모유 수유', '약물 중독', '최면/세뇌', '타락함', '노예 각인', '펫 취급', '이중인격', '인체개조', '신체 결손', '발정기'], level: 3 }
                        ]
                    }
                ]
            },
            worlds: {
                 sections: [
                    { title: '핵심 장르', singleChoice: true, tags: ['현대/일상', '판타지/이세계', '아카데미/학원', '헌터/게이트', '무협/동양풍', 'SF/사이버펑크', '아포칼립스/생존', '정조역전/남녀역전', '연예계/매니지먼트', '인터넷 방송(인방)', '유흥가/화류계', '시골/촌구석'], level: 1 },
                    { title: '도입부 상황/클리셰', singleChoice: true, tags: ['섹스해야 열리는 방', '최면/상식개변', '시간 정지', '상태창/퀘스트', '투명 인간', '최음제/약물', '수면 간', '빙의/환생', '매니저/경호원', '비밀 수업/과외', '약점 잡힘/협박', '빚/노예 계약', '동거 시작', '운명적 재회', '술김에 실수', '코치/트레이너', '여자만 사는 집, 아파트'], level: 1 },
                    { title: '관계 주도권', singleChoice: true, tags: ['유저 절대 우위', '캐릭터 우위', '대등한 관계', '상호 의존/공범', '혐관(애증)'], level: 1 }, 
                    { title: '분위기/태그', singleChoice: false, tags: ['순애/달달함', '하드코어/능욕', '타락/암타', '피카레스크', '하렘', '개그/코믹', '시리어스/피폐', '퇴폐적/느와르', 'NTR/네토리'], level: 2 },
                ]
            }
        };




        // 1. 환경 설정 및 상수
        const EnvConfig = {
            STORAGE_KEY: 'novel_ai_data_main',
            SETTINGS_KEY: 'novel_ai_settings_main',
        };


        // 2. 데이터 베이스 (DB & Settings)
        const DB = { chats: [], worlds: [] }; 
        const SETTINGS = { 
            apiKey: '', coreRules: [], dicRules: [], globalLorebook: [], 
            temperature: 0.9, typingSpeed: 15, currentModel: 'gemini-3-pro',
            uncensored: true, fontSize: 16, maxOutputTokens: 4000,
            novelViewpoint: '3인칭 제한적 시점 (추천)', novelStyle: '웹소설체', novelRatio: '밸런스형',
            novelPacing: '보통 (밸런스)', nsfwLevel: '노멀 (성관계 해금)', 
            outputLength: '보통 (30문장 내외)', charAttitude: '보통 (Neutral)',
            enableMultiChoice: false,
            macros: [
                { label: "유저 행동 침범 방지", content: "유저 행동이나 대사를 대신 작성하지 말고 캐릭터의 반응만 서술." },
                { label: "감각적 묘사 강화", content: "단순 설명 대신 시각, 청각, 촉각, 후각을 활용해 문학적으로 묘사." },
                { label: "내면 묘사", content: "행동뿐만 아니라 캐릭터의 생각과 내면 갈등을 서술." },
                { label: "슬로우 모션", content: "이 장면의 분위기와 감정선을 상세히." },
                { label: "장면 전환", content: "이 장면을 마무리하고 자연스럽게 다음 시간대나 장소로 넘어가기." }
            ]
        };



// ▼▼▼ [신규] 소설 상세 설정 통합 구성 데이터 ▼▼▼
// 항목을 추가하고 싶으면 여기에만 추가하면 됩니다.
const NOVEL_SETTINGS_CONFIG = [
    { 
        key: 'novelViewpoint', 
        label: '서술 시점', 
        options: ['3인칭 제한적 시점 (추천)', '3인칭 제한적 (히로인 내면)', '1인칭 주인공 시점', '3인칭 관찰자 시점', '3인칭 전지적 작가 시점'] 
    },
    { 
        key: 'novelRatio', 
        label: '서술/대화 비중', 
        options: ['밸런스형', '대화 중심 (여자 발언 위주)', '대화 중심', '지문/묘사 중심'] 
    },
    { 
        key: 'novelPacing', 
        label: '서술 호흡', 
        options: ['빠른 전개 (사건 위주)', '보통 (밸런스)', '느린 전개 (세밀한 묘사)'] 
    },
    { 
        key: 'novelStyle', 
        label: '문체 스타일', 
        options: ['웹소설체', '간결/건조체', '만연/화려체'] 
    },
    { 
        key: 'nsfwLevel', 
        label: '수위 강도', 
        options: ['전연령 (스킨십/키스)', '노멀 (성관계 해금)', '고수위 (자극적/적나라함)', '초고수위 (에로게/동인지)'] 
    },
    { 
        key: 'novelAtmosphere', 
        label: '분위기', 
        options: [
            '유쾌/코믹 (가벼운 분위기)', 
            '일상/힐링 (포근한 분위기)', 
            '담백/건조 (사실적 묘사)', 
            '진지/시리어스 (무거운 서사)', 
            '피폐/느와르 (어둡고 절망적)', 
            '공포/스릴러 (긴장감 조성)', 
            '달달/로맨스 (설레는 무드)', 
            '관능/퇴폐 (끈적한 분위기)'
        ] 
    },
    { 
        key: 'charAttitude', 
        label: '캐릭터 태도', 
        options: ['철벽 (차가움/방어적)', '도도함 (오만/내려다봄)', '보통 (일반적)', '적극적 (유혹/리드)', '금사빠 (맹목적 애정)'] 
    },
{ 
    key: 'outputLength', // 👈 여기 이름이 'novelLength' 등으로 되어있으면 'outputLength'로 고쳐야 함
    label: '1회 출력 분량', 
    options: ['짧게 (150단어 내외)', '보통 (400단어 내외)', '길게 (800단어 이상)'] 
}
];


// 3. 앱 상태 관리 (App State) - 리팩토링된 전역 상태
        const AppState = {
            currentTab: 'chats',
            currentRightTab: 'tools',
            sessionId: null,      
            worldId: null,        
            
            // 상태 플래그
            isGenerating: false,  
            isTyping: false,
            isNewSessionMode: false,
            isDirectorMode: false,
            isDetailGenCancelled: false,

            // 컨트롤러 및 타이머
            abortController: null, 
            typingTimer: null,
            typingQueue: [],
            
            // UI 참조 및 디버깅
            lastSentPrompt: "",
            lastTokenUsage: null,
            activeTextareaTarget: null,
            currentMsgElement: null
        };


        // 4. 데이터 관리자 (Data Manager)
// 4. 데이터 관리자 (Data Manager) - 저장 키 통일
const DataManager = {
    save: function() {
        try {
            localStorage.setItem(EnvConfig.STORAGE_KEY, JSON.stringify(DB));
        } catch(e) { console.error("Save Error:", e); }
    },
    load: function() {
        try {
            const d = localStorage.getItem(EnvConfig.STORAGE_KEY);
            if(d) Object.assign(DB, JSON.parse(d));
        } catch(e) {}
    },
    saveSettings: function() {
        try {
            // EnvConfig.SETTINGS_KEY(novel_ai_settings_main)로 저장 이름 통일
            localStorage.setItem(EnvConfig.SETTINGS_KEY, JSON.stringify(SETTINGS));
            console.log("설정 저장 완료:", SETTINGS);
        } catch(e) { console.error("Settings Save Error:", e); }
    },
    loadSettings: function() {
        try {
            const s = localStorage.getItem(EnvConfig.SETTINGS_KEY);
            if(s) {
                Object.assign(SETTINGS, JSON.parse(s));
                console.log("설정 로드 완료:", SETTINGS);
            }
        } catch(e) {}
    }
};


        // 호환성 유지용 래퍼 (나중에 삭제 가능)
        function saveData() { DataManager.save(); }
        function loadData() { DataManager.load(); }
        function saveSettings() { DataManager.saveSettings(); }
        function loadSettings() { DataManager.loadSettings(); }


// ▼▼▼ [리팩토링] 2단계: 앱의 수명주기를 관리하는 컨트롤러 객체 ▼▼▼
const App = {
    // 1. 앱 초기화 진입점
    init: function() {
        console.log("🚀 E.No.S App Initializing...");
        
        this.setupTheme();      // 테마 설정
        this.setupMarkdown();   // 마크다운 설정
        this.loadData();        // 데이터 로드
        this.setupEventListeners(); // 이벤트 리스너 연결
        this.renderInitialUI(); // 초기 화면 그리기
        this.checkQuickStart(); // 퀵 스타트 상태 확인
    },

    // 2. 다크모드 및 테마 설정
    setupTheme: function() {
        const savedDark = localStorage.getItem('novel_ai_dark_mode');
        const toggle = document.getElementById('dark-mode-toggle');
        
        if (savedDark === 'true') {
            document.documentElement.classList.add('dark');
            if(toggle) toggle.checked = true;
        } else {
            document.documentElement.classList.remove('dark');
            if(toggle) toggle.checked = false;
        }
    },

    // 3. 라이브러리 설정
    setupMarkdown: function() {
        if(typeof marked !== 'undefined') {
            marked.setOptions({ breaks: true, gfm: true });
        }
    },

    // 4. 데이터 불러오기
    loadData: function() {
        DataManager.load(); 
        DataManager.loadSettings();
    },

    // 5. 이벤트 리스너 통합 관리
    setupEventListeners: function() {
        // 메시지 입력창 엔터키 전송
        const msgInput = document.getElementById('msg-input');
        if (msgInput) {
            msgInput.addEventListener("keydown", (e) => {
                if(window.innerWidth < 768) return; // 모바일은 엔터로 줄바꿈 허용
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    handleFormSubmit(); 
                }
            });
        }

        // 토큰 슬라이더 실시간 값 표시
        const slider = document.getElementById('core-max-token-slider');
        if(slider) {
            slider.addEventListener('input', function(e) {
                document.getElementById('core-max-token-val').innerText = e.target.value;
            });
        }
        
        // (필요 시 여기에 다른 전역 이벤트 리스너를 추가하면 됩니다)
    },

    // 6. 초기 UI 렌더링
    renderInitialUI: function() {
        // 탭 초기화 (채팅 목록)
        switchNav('chats');
        
        // 오른쪽 사이드바 및 폰트 적용
        renderRightSidebar();
        applyFontSize(SETTINGS.fontSize);
        
        // 모델명 표시 업데이트
const modelDisplay = document.getElementById('model-display');
if (modelDisplay) {
    const provider = SETTINGS.aiProvider || 'gemini';
    const modelName = (provider === 'gemini') 
        ? (SETTINGS.currentModel || 'gemini-3-pro-preview') 
        : (SETTINGS.customModel || 'Custom Model');
    
    modelDisplay.innerText = 'Model: ' + modelName;
}
        
        // 설정 탭 초기화
        switchCoreTab('api'); 
    },

    // 7. 세션이 없을 때 빈 화면 처리
    checkQuickStart: function() {
        if (!AppState.sessionId) {
            const inputArea = document.getElementById('input-area');
            const msgInput = document.getElementById('msg-input');
            if(inputArea) {
                inputArea.classList.remove('hidden');
                inputArea.classList.add('flex');
            }
            if(msgInput) msgInput.placeholder = "입력하기";
        }
    }
};
// ▲▲▲ [리팩토링] App 객체 끝 ▲▲▲


// [신규] 폼 제출 통합 핸들러 (엔터키 or 버튼 클릭 시 호출)
function handleFormSubmit() {
    if (AppState.isGenerating) {
        // 생성 중이면 -> 중단 기능 수행
        cancelGeneration();
    } else {
        // 대기 중이면 -> 메시지 전송 수행
        sendMessage();
    }
}


// [신규 기능] 버튼 상태 변경 함수 (전송 ↔ 정지)
function updateSendButtonState(state) {
    const btn = document.getElementById('send-btn');
    if (!btn) return;


if (state === 'generating') {
        // 생성 중: 파란색 배경 + 하얀색 스피너(뺑뺑이)
        btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
        
        // 빨간색 색상 제거 (파란색 유지)
        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
        btn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        
        // (선택 사항) 마우스를 올렸을 때만 '정지' 아이콘 보여주기
        // btn.title = "클릭하여 생성 중단";
    } else {
        // 대기 중일 때: 파란색 전송 버튼
        btn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
        btn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
    }
}


// [신규 기능] 폼 제출 통합 핸들러
function handleFormSubmit() {
    if (AppState.isGenerating) {
        cancelGeneration(); // 생성 중이면 멈춤
    } else {
        sendMessage(); // 아니면 전송
    }
}        
        function cancelDetailGeneration() {
            AppState.isDetailGenCancelled = true;
            if(AppState.abortController) AppState.abortController.abort(); 
            document.getElementById('modal-loading-overlay-details').classList.add('hidden');
            document.getElementById('modal-loading-overlay-details').classList.remove('flex');
            showMessage("설정 생성이 중단되었습니다.");
        }
        
        function editChatTitle() {
            if(!AppState.sessionId) return;
            const currentTitle = document.getElementById('header-title').innerText;
            const newTitle = prompt("대화 제목을 입력하세요:", currentTitle);
            if(newTitle && newTitle.trim() !== "") {
                const chat = DB.chats.find(c => c.id === AppState.sessionId);
                if(chat) {
                    chat.title = newTitle.trim();
                    document.getElementById('header-title').innerText = chat.title;
                    saveData();
                    renderSidebar();
                }
            }
        }


        function loadData() { try { const d = localStorage.getItem(STORAGE_KEY); if(d) Object.assign(DB, JSON.parse(d)); if(!DB.chats) DB.chats=[]; if(!DB.worlds) DB.worlds=[]; } catch(e){} }


function loadSettings() { 
    try { 
        const s = localStorage.getItem(SETTINGS_KEY); 
        if(s) Object.assign(SETTINGS, JSON.parse(s));


        if(!SETTINGS.coreRules) SETTINGS.coreRules = []; 
        if(!SETTINGS.dicRules) SETTINGS.dicRules = []; 
        if(!SETTINGS.globalLorebook) SETTINGS.globalLorebook = []; 
                if(SETTINGS.typingSpeed===undefined) SETTINGS.typingSpeed=15; 
                if(SETTINGS.uncensored===undefined) SETTINGS.uncensored=true;
                if(!SETTINGS.fontSize) SETTINGS.fontSize=16;
                if(!SETTINGS.novelViewpoint) SETTINGS.novelViewpoint = '3인칭 제한적 시점 (추천)';
                if(!SETTINGS.novelStyle) SETTINGS.novelStyle = '웹소설체';
                if(!SETTINGS.novelRatio) SETTINGS.novelRatio = '밸런스형';
                if(!SETTINGS.maxOutputTokens) SETTINGS.maxOutputTokens = 4000;


if (typeof NOVEL_SETTINGS_CONFIG !== 'undefined') {
            NOVEL_SETTINGS_CONFIG.forEach(item => {
                // 저장된 값이 없으면(undefined), 옵션의 첫 번째 값을 기본값으로 설정
                if (SETTINGS[item.key] === undefined && item.options.length > 0) {
                    SETTINGS[item.key] = item.options[0];
                }
            });
        }


if(!SETTINGS.novelPacing) SETTINGS.novelPacing = '보통 (밸런스)'; // 변경된 텍스트로 기본값 설정
        if(!SETTINGS.nsfwLevel) SETTINGS.nsfwLevel = '노멀 (성관계 해금)';
        if(!SETTINGS.outputLength) SETTINGS.outputLength = '보통 (30문장 내외)';
                if(!SETTINGS.charAttitude) SETTINGS.charAttitude = '보통 (Neutral)';
                if(SETTINGS.enableMultiChoice === undefined) SETTINGS.enableMultiChoice = false; 
                // ▲▲▲ [신규] 끝 ▲▲▲


                // [추가] 매크로 초기값 설정
                if(!SETTINGS.macros) {
                    SETTINGS.macros = [
                        { label: "유저 행동 침범 방지", content: "유저 행동이나 대사를 대신 작성하지 말고 캐릭터의 반응만 서술." },
                        { label: "감각적 묘사 강화", content: "단순 설명 대신 시각, 청각, 촉각, 후각을 활용해 문학적으로 묘사." },
                        { label: "내면 묘사", content: "행동뿐만 아니라 캐릭터의 생각과 내면 갈등을 서술." },
                        { label: "슬로우 모션", content: "이 장면의 분위기와 감정선을 상세히." },
                        { label: "장면 전환", content: "이 장면을 마무리하고 자연스럽게 다음 시간대나 장소로 넘어가기." }
                    ];
                } // [중요] if문 닫기
            } catch(e){} // [중요] try문 닫고 catch 연결
        }


// 기존의 복잡한 내용을 지우고 이 한 줄만 남기세요.
function saveSettings() { DataManager.saveSettings(); }

        function showMessage(msg) {
            const d = document.createElement('div');
            // [변경] 알림창 위치를 상단 중앙으로 변경
            d.className = "fixed top-5 left-1/2 transform -translate-x-1/2 z-[100] p-4 bg-slate-800 text-white rounded shadow-lg transition opacity-100 max-w-xs text-center";
            d.innerText = msg; document.body.appendChild(d);
            setTimeout(()=>d.style.opacity=0, 2500); setTimeout(()=>d.remove(), 3000);
        }


// [추가] 안전 닫기: 실수로 배경을 눌렀을 때 확인창 띄우기
        function tryCloseModal(id) {
            if (confirm("작성 중인 내용이 있을 수 있습니다. 창을 닫으시겠습니까?")) {
                closeModal(id);
            }
        }


        
        function closeModal(id) { 
            document.getElementById(id).classList.add('hidden');
            const container = document.getElementById('modal-container');
            const openModals = Array.from(container.children).filter(child => !child.classList.contains('hidden'));
            if(openModals.length === 0) {
                container.classList.add('hidden');
            }
        }
        
        function openModalInternal(id) {
            document.getElementById('modal-container').classList.remove('hidden');
            document.getElementById(id).classList.remove('hidden');
        }


        function switchNav(tab) {
            AppState.currentTab = tab;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('nav-'+tab).classList.add('active');
            ['chats','worlds'].forEach(t => document.getElementById('panel-'+t).classList.add('hidden'));
            document.getElementById('panel-'+tab).classList.remove('hidden');
            renderSidebar();
        }
        
        // [수정] 사이드바 토글 로직 (PC 닫기 지원)
        function toggleSidebar() { 
            const sb = document.getElementById('sidebar');
            // Mobile: 'open' toggles slide-in
            sb.classList.toggle('open');
            // PC: 'closed' toggles width to 0
            sb.classList.toggle('closed');
            
            document.getElementById('dim-overlay').classList.toggle('hidden');
        } 
        
        function toggleRightSidebar() { 
            const sb = document.getElementById('right-sidebar');
            sb.classList.toggle('closed'); 
            sb.classList.toggle('open');
            renderRightSidebar(); 
        }
        
        function closeAllSidebars() { 
            document.getElementById('sidebar').classList.remove('open');
            document.getElementById('sidebar').classList.add('closed'); // PC 대응
            document.getElementById('right-sidebar').classList.remove('open');
            document.getElementById('right-sidebar').classList.add('closed'); 
            document.getElementById('dim-overlay').classList.add('hidden');
        }


// ▼▼▼ [수정됨] 오른쪽 사이드바 3단 분리 리팩토링 시작 ▼▼▼


function switchRightTab(tab) {
    AppState.currentRightTab = tab;
    renderRightSidebar();
}


// [메인] 3단 탭 구조가 적용된 렌더링 함수
function renderRightSidebar() {
    const p = document.getElementById('right-sidebar-content');
    p.innerHTML = ''; 


    // 1. 탭 버튼 영역 (3개로 분할)
    const tabContainer = document.createElement('div');
    tabContainer.className = "flex border-b border-gray-200 mb-4 bg-gray-50 dark:bg-slate-900";
    tabContainer.innerHTML = `
        <button onclick="switchRightTab('tools')" class="right-tab-btn ${AppState.currentRightTab === 'tools' ? 'active' : ''}">
            <i class="fa-solid fa-toolbox mr-1"></i> 도구
        </button>
        <button onclick="switchRightTab('settings')" class="right-tab-btn ${AppState.currentRightTab === 'settings' ? 'active' : ''}">
            <i class="fa-solid fa-sliders mr-1"></i> 설정
        </button>
        <button onclick="switchRightTab('core')" class="right-tab-btn ${AppState.currentRightTab === 'core' ? 'active' : ''}">
            <i class="fa-solid fa-robot mr-1"></i> 지침
        </button>
    `;
    p.appendChild(tabContainer);


    // 2. 내용 컨테이너
    const contentContainer = document.createElement('div');
    contentContainer.id = 'right-tab-content';
    p.appendChild(contentContainer);


    // 3. 탭별 렌더링 호출
    if (AppState.currentRightTab === 'tools') {
        renderRightTools(contentContainer);
    } else if (AppState.currentRightTab === 'settings') {
        renderRightSettings(contentContainer);
    } else {
        renderRightCoreRules(contentContainer);
    }
}


function renderRightTools(container) {
    const chat = DB.chats.find(c => c.id === AppState.sessionId);
    let worldInfo = '대화 선택 안됨';
    
    if (chat) {
        if (chat.isNovelMode) worldInfo = `소설 모드: ${chat.title}`;
        else {
            const w = DB.worlds.find(x => x.id === chat.worldId);
            if(w) worldInfo = w.name;
        }
    }


    // 책갈피 리스트 (기존 로직 유지)
    let bookmarkListHtml = '<div class="text-gray-400 text-xs p-2 text-center">저장된 책갈피가 없습니다.</div>';
    if (chat && chat.history) {
        const bookmarks = chat.history
            .map((msg, index) => ({ msg, index }))
            .filter(item => item.msg.bookmarked);


        if (bookmarks.length > 0) {
            bookmarkListHtml = bookmarks.map(item => {
                const summary = item.msg.text.substring(0, 30) + (item.msg.text.length > 30 ? '...' : '');
                const nameDisplay = item.msg.bookmarkName ? `<div class="font-bold text-sm text-indigo-700 dark:text-indigo-400 mb-1 border-b border-yellow-200 dark:border-gray-600 pb-1">${item.msg.bookmarkName}</div>` : '';
                
                return `
                <div class="border rounded-lg p-2 bg-yellow-50 dark:bg-slate-800 border-yellow-100 dark:border-slate-700 hover:shadow-md transition group relative">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] font-bold text-yellow-700 dark:text-yellow-500 bg-yellow-100 dark:bg-slate-700 px-1.5 py-0.5 rounded">Turn ${item.index + 1}</span>
                        <div class="flex items-center gap-1">
                             <button onclick="editBookmarkName(${item.index})" class="text-gray-400 hover:text-indigo-600 px-1"><i class="fa-solid fa-pen text-[10px]"></i></button>
                             <button onclick="deleteBookmarkFromSidebar(${item.index})" class="text-gray-400 hover:text-red-500 px-1"><i class="fa-solid fa-trash text-[10px]"></i></button>
                        </div>
                    </div>
                    ${nameDisplay}
                    <div class="text-xs text-gray-700 dark:text-gray-300 font-medium mb-2 break-all leading-tight opacity-80">${summary}</div>
                    <button onclick="loadBookmark(${item.index})" class="w-full py-1.5 bg-white dark:bg-slate-700 border border-yellow-200 dark:border-slate-600 text-yellow-700 dark:text-yellow-500 font-bold text-xs rounded hover:bg-yellow-600 hover:text-white transition flex items-center justify-center gap-1">
                        <i class="fa-solid fa-rotate-left"></i> 이 시점 분기
                    </button>
                </div>`;
            }).join('<div class="h-2"></div>'); 
        }
    }


    container.innerHTML = `
    <div class="mb-4 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg p-3 shadow-sm">
        <div class="text-xs font-bold text-gray-400 mb-1">CURRENT CONTEXT</div>
        <div class="font-bold text-gray-800 dark:text-gray-200 text-sm flex items-center gap-2">
            <i class="fa-solid fa-globe text-indigo-500"></i> ${worldInfo}
        </div>
        <div class="mt-2 text-xs text-gray-500">
            ${chat ? `<span class="bg-gray-100 dark:bg-slate-700 px-2 py-1 rounded">턴 수: ${chat.history.length}</span>` : ''}
        </div>
    </div>


    <div class="mb-4">
        <div class="text-xs font-bold text-gray-400 mb-2 px-1">ACTIONS</div>
        <div class="grid grid-cols-3 gap-2">
            <button onclick="openMemoryModal()" class="tool-btn bg-indigo-50 text-indigo-600 dark:bg-slate-800 dark:text-indigo-400 border border-indigo-100 dark:border-slate-600"><i class="fa-solid fa-brain mb-1"></i>장기 기억</button>
            <button onclick="openSessionSettings('edit')" class="tool-btn bg-slate-50 text-slate-600 dark:bg-slate-800 dark:text-slate-400 border border-slate-200 dark:border-slate-600"><i class="fa-solid fa-users-gear mb-1"></i>재설정</button>
            <button onclick="exportChat()" class="tool-btn bg-emerald-50 text-emerald-600 dark:bg-slate-800 dark:text-emerald-400 border border-emerald-100 dark:border-slate-600"><i class="fa-solid fa-download mb-1"></i>대화 저장</button>
            <button onclick="clearChat()" class="tool-btn bg-red-50 text-red-500 dark:bg-slate-800 dark:text-red-400 border border-red-100 dark:border-slate-600"><i class="fa-solid fa-eraser mb-1"></i>대화 정리</button>
            <button onclick="handleNovelUploadClick()" class="tool-btn bg-blue-50 text-blue-600 dark:bg-slate-800 dark:text-blue-400 border border-blue-100 dark:border-slate-600"><i class="fa-solid fa-folder-open mb-1"></i>파일 열기</button>
            <button onclick="showLastPrompt()" class="tool-btn bg-amber-50 text-amber-600 dark:bg-slate-800 dark:text-amber-400 border border-amber-100 dark:border-slate-600"><i class="fa-solid fa-bug mb-1"></i>디버그</button>
        </div>
        <style>.tool-btn { display:flex; flex-direction:column; align-items:center; justify-content:center; padding:0.5rem; border-radius:0.5rem; font-size:0.65rem; font-weight:bold; transition:all 0.2s; } .tool-btn:hover { transform:translateY(-1px); box-shadow:0 2px 4px rgba(0,0,0,0.05); }</style>
    </div>
    
    <div class="mb-4">
        <div class="text-xs font-bold text-gray-400 mb-2 px-1 flex justify-between items-center">
            <span>BOOKMARKS</span>
        </div>
        <div id="bookmark-list-container" class="space-y-0">${bookmarkListHtml}</div>
    </div>


    <div>
        <div class="flex justify-between items-center mb-2 px-1">
            <div class="text-xs font-bold text-gray-400">GLOBAL LOREBOOK</div>
            <button onclick="addGlobalLoreFromSidebar()" class="text-xs bg-indigo-50 text-indigo-600 px-2 py-1 rounded hover:bg-indigo-100 font-bold transition">+ 추가</button>
        </div>
        <div id="lore-list-container" class="space-y-2"></div>
    </div>`;


    // ▼▼▼ 로어북 렌더링 (디자인 변경됨) ▼▼▼
    const loreContainer = container.querySelector('#lore-list-container');
    
    if (!SETTINGS.globalLorebook || SETTINGS.globalLorebook.length === 0) {
        loreContainer.innerHTML = `<div class="text-center text-xs text-gray-400 py-4 cursor-pointer hover:text-indigo-500" onclick="addGlobalLoreFromSidebar()">등록된 로어가 없습니다.<br>'+ 추가' 버튼을 눌러보세요.</div>`;
    } else {
        SETTINGS.globalLorebook.forEach((lore, idx) => {
            const div = document.createElement('div');
            // '지침'과 동일한 카드 디자인 적용
            div.className = "flex items-center justify-between p-2 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded mb-1.5 shadow-sm group hover:border-indigo-300 transition-colors";
            div.innerHTML = `
                <div class="flex flex-col overflow-hidden flex-1 cursor-pointer py-1" onclick="editGlobalLore(${idx})" title="클릭하여 수정">
                    <div class="font-bold text-xs text-indigo-700 dark:text-indigo-400 truncate">${lore.title}</div>
                    <div class="text-[10px] text-gray-500 dark:text-gray-400 truncate flex items-center gap-1">
                        ${lore.keywords ? '<i class="fa-solid fa-key text-[9px]"></i> ' + lore.keywords : '<i class="fa-solid fa-infinity text-[9px]"></i> 상시 적용'}
                    </div>
                </div>
                <div class="flex-shrink-0 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button onclick="editGlobalLore(${idx})" class="text-gray-400 hover:text-indigo-600 px-1" title="수정"><i class="fa-solid fa-pen text-[10px]"></i></button>
                    <button onclick="deleteGlobalLore(${idx})" class="text-gray-400 hover:text-red-500 px-1" title="삭제"><i class="fa-solid fa-trash text-[10px]"></i></button>
                </div>
            `;
            loreContainer.appendChild(div);
        });
    }
}


/* ▼▼▼ [복구됨] 누락되었던 설정 탭 렌더링 함수 ▼▼▼ */
function renderRightSettings(container) {
    let html = '<div class="space-y-3 p-1">';


    // NOVEL_SETTINGS_CONFIG 배열을 순회하며 설정 카드 생성
    NOVEL_SETTINGS_CONFIG.forEach(item => {
        // 해당 설정이 켜져있는지 확인 (기본값: true)
        const isEnabled = SETTINGS[item.key + '_enabled'] !== false;
        
        // 옵션 목록 생성
        const optionsHtml = item.options.map(opt => 
            `<option value="${opt}" ${SETTINGS[item.key] === opt ? 'selected' : ''}>${opt}</option>`
        ).join('');


        // HTML 조립
        html += `
        <div class="bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg p-3 shadow-sm transition-opacity ${isEnabled ? '' : 'opacity-60'}">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-500 dark:text-gray-400 flex items-center gap-1">
                    ${item.label}
                </span>
                
                <label class="relative inline-flex items-center cursor-pointer" title="이 설정 켜기/끄기">
                    <input type="checkbox" class="sr-only peer" 
                        ${isEnabled ? 'checked' : ''}
                        onchange="updateSidebarToggle('${item.key}', this.checked)">
                    <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                </label>
            </div>
            
            <select 
                class="sidebar-select w-full p-2 text-xs border rounded bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-200 focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed"
                ${isEnabled ? '' : 'disabled'}
                onchange="updateSidebarSetting('${item.key}', this.value)">
                ${optionsHtml}
            </select>
        </div>`;
    });


    html += `
        <div class="bg-white dark:bg-slate-800 border dark:border-slate-700 rounded-lg p-3 shadow-sm flex justify-between items-center mt-4">
            <span class="text-xs font-bold text-gray-500 dark:text-gray-400 flex items-center gap-1">
                <i class="fa-solid fa-list-ol text-indigo-500"></i> 선택지 자동 생성
            </span>
            <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" class="sr-only peer" 
                    ${SETTINGS.enableMultiChoice ? 'checked' : ''}
                    onchange="updateSidebarSetting('enableMultiChoice', this.checked)">
                <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-slate-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
            </label>
        </div>
        
        <div class="text-[10px] text-gray-400 text-center mt-4 p-2">
            * 토글을 끄면 해당 설정은 프롬프트에 포함되지 않아<br>AI가 더 자유롭게 판단합니다.
        </div>
    </div>`;


    container.innerHTML = html;
}
/* ▲▲▲ 추가 끝 ▲▲▲ */


// ▼▼▼ [신규] 설정별 활성화/비활성화 토글 함수 ▼▼▼
function updateSidebarToggle(key, isChecked) {
    // 키 이름 뒤에 '_enabled'를 붙여서 상태 저장 (예: novelViewpoint_enabled)
    SETTINGS[key + '_enabled'] = isChecked;
    saveSettings();
    renderRightSidebar(); // 화면 갱신 (입력창 비활성화 시각 효과를 위해)
}


function renderRightCoreRules(container) {
    let html = '';
    // 안전장치: coreRules가 없으면 빈 배열로 처리
    const rules = SETTINGS.coreRules || [];


    // 1. 목록이 비어있을 때 (안내 문구 표시)
    if (rules.length === 0) {
        html = `
        <div class="text-center p-6 text-gray-400 cursor-pointer hover:text-indigo-500 transition border-2 border-dashed border-gray-200 dark:border-slate-700 rounded-lg" onclick="addCoreRuleFromSidebar()">
            <i class="fa-solid fa-plus-circle text-2xl mb-2"></i><br>
            <span class="text-xs">등록된 지침이 없습니다.<br>클릭하여 추가하세요.</span>
        </div>`;
    } else {
        // 2. 목록이 있을 때 (리스트 생성)
        html += '<div class="space-y-2">';
        rules.forEach((rule, idx) => {
            const isEnabled = rule.enabled !== false;
            html += `
            <div class="group flex items-center justify-between p-2 bg-white dark:bg-slate-800 border dark:border-slate-700 rounded shadow-sm hover:border-indigo-300 transition-all">
                <div class="flex items-center gap-2 overflow-hidden flex-1">
                    <input type="checkbox" ${isEnabled ? 'checked' : ''}
                        onchange="toggleCoreRule(${idx}, this.checked)"
                        class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 cursor-pointer flex-shrink-0"
                        title="이 지침 켜기/끄기">
                    
                    <span class="text-xs font-medium text-gray-700 dark:text-gray-200 truncate cursor-pointer hover:text-indigo-600 flex-1 py-1"
                          onclick="editCoreRuleFromSidebar(${idx})" title="${String(rule.content || '').replace(/"/g, '&quot;').substring(0, 100)}">
                        ${rule.title || '규칙 ' + (idx + 1)}
                    </span>
                </div>


                <div class="flex-shrink-0 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button onclick="editCoreRuleFromSidebar(${idx})" class="text-gray-400 hover:text-indigo-600 p-1" title="수정">
                        <i class="fa-solid fa-pen text-[10px]"></i>
                    </button>
                    <button onclick="deleteCoreRuleFromSidebar(${idx})" class="text-gray-400 hover:text-red-500 p-1" title="삭제">
                        <i class="fa-solid fa-trash text-[10px]"></i>
                    </button>
                </div>
            </div>`;
        });
        html += '</div>';
    }


    // 3. 최종적으로 화면에 뿌리기
    container.innerHTML = `
    <div class="space-y-1 p-1">
        <div class="bg-gray-50 dark:bg-slate-900 p-3 rounded-lg border dark:border-slate-700">
             <div class="flex justify-between items-center mb-3">
                <div class="font-bold text-sm text-gray-800 dark:text-gray-200">
                    <i class="fa-solid fa-robot mr-2 text-indigo-500"></i>AI 핵심 지침
                </div>
                <button onclick="addCoreRuleFromSidebar()" class="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded hover:bg-indigo-200 font-bold transition">
                    + 추가
                </button>
            </div>
            
            <div class="max-h-[70vh] overflow-y-auto pr-1">
                ${html}
            </div>


            <div class="mt-3 text-[10px] text-gray-400 leading-tight">
                * 체크박스를 끄면 해당 지침은 AI에게 전달되지 않습니다.
            </div>
        </div>
    </div>`;
}


// ▼▼▼ [중요] 사이드바 값 변경 시 즉시 저장하는 함수 ▼▼▼
function updateSidebarSetting(key, value) {
    // 1. 설정값 업데이트
    SETTINGS[key] = value;
    
    // 2. 즉시 저장 (새로고침 해도 유지되도록)
    saveSettings();


    // 3. (선택사항) 로그 확인 - F12 콘솔에서 값이 바뀌는지 확인 가능
    console.log(`설정 변경됨: ${key} = ${value}`);
}


// ▼▼▼ [수정] 사이드바 토글 시 -> 저장 및 모달 동기화 ▼▼▼
function toggleCoreRule(idx, enabled) {
    if(SETTINGS.coreRules[idx]) {
        // 1. 데이터 변경
        SETTINGS.coreRules[idx].enabled = enabled;
        
        // 2. 즉시 영구 저장
        saveSettings();
        
        // 3. [핵심] 전역 설정 모달이 열려 있다면, 거기도 즉시 반영!
        const coreList = document.getElementById('core-rules-list');
        if (coreList && coreList.offsetParent !== null) { 
            renderCoreRules(); 
        }
    }
}


function editCoreRuleFromSidebar(idx) {
    const rule = SETTINGS.coreRules[idx];
    const body = document.getElementById('modal-body');


    // 1. 에디터 모달 내용 주입 (넓은 입력창 제공)
    body.innerHTML = `
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">지침 제목</label>
                <input id="quick-edit-title" type="text" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100 focus:ring-2 focus:ring-indigo-500" value="${String(rule.title).replace(/"/g, '&quot;')}" placeholder="예: 전투 묘사 강화">
            </div>
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">지침 내용 (프롬프트)</label>
                <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">AI가 이 규칙을 어떻게 따라야 하는지 구체적으로 적어주세요.</div>
                <textarea id="quick-edit-content" rows="15" class="w-full p-3 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100 resize-none text-sm leading-relaxed focus:ring-2 focus:ring-indigo-500" placeholder="내용을 입력하세요...">${rule.content}</textarea>
            </div>
        </div>
    `;


    // 2. 모달 UI 설정
    document.getElementById('modal-title').innerText = "AI 핵심 지침 수정";
    document.getElementById('modal-delete-btn').classList.add('hidden');
    document.getElementById('btn-gen-details').classList.add('hidden'); // 불필요한 버튼 숨김


    // 3. 저장 버튼 기능 재정의
    const saveBtn = document.getElementById('modal-save-btn');
    saveBtn.onclick = () => {
        const titleVal = document.getElementById('quick-edit-title').value.trim();
        // 제목이 비어있으면 저장 안 함 (선택사항)
        if (!titleVal) return alert("제목을 입력해주세요.");


        SETTINGS.coreRules[idx].title = titleVal;
        SETTINGS.coreRules[idx].content = document.getElementById('quick-edit-content').value;
        
        saveSettings();       // 저장
        renderRightSidebar(); // 사이드바 갱신
        closeModal('editor-modal');
    };


    // 4. 모달 열기 및 리사이즈 핸들 부착
    openModalInternal('editor-modal');
    setTimeout(() => {
        const textarea = document.getElementById('quick-edit-content');
        if(textarea) {
            textarea.focus(); // 바로 입력 가능하게 포커스
            makeResizable(textarea);
        }
    }, 50);
}


// ▼▼▼ [수정] 지침 추가 시 리스트가 없으면 생성 후 추가 ▼▼▼
function addCoreRuleFromSidebar() {
    // 안전장치: 리스트가 없으면 생성
    if (!SETTINGS.coreRules) SETTINGS.coreRules = [];


    // 빈 규칙 생성 후 푸시
    SETTINGS.coreRules.push({ title: '새 규칙', content: '', enabled: true });
    saveSettings();
    renderRightSidebar();
    
    // 방금 추가한 규칙(마지막 인덱스)을 즉시 에디터로 열기
    editCoreRuleFromSidebar(SETTINGS.coreRules.length - 1);
}


function deleteCoreRuleFromSidebar(idx) {
    if(confirm("이 지침을 삭제하시겠습니까?")) {
        SETTINGS.coreRules.splice(idx, 1);
        saveSettings();
        renderRightSidebar();
    }
}


// ▲▲▲ [수정됨] 오른쪽 사이드바 3단 분리 리팩토링 끝 ▲▲▲


function handleNovelUploadClick() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true; // 다중 선택
            input.accept = '.txt, .jpg, .jpeg, .png, .webp, .avif';
            
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;


                if (files.length > 10) {
                    alert('최대 10개까지만 업로드할 수 있습니다.\n상위 10개의 파일만 병합하여 로드합니다.');
                }
                
                // 선택된 파일(최대 10개)을 한꺼번에 처리하는 함수 호출
                processBatchFiles(files.slice(0, 10));
            };
            
            input.click();
        }

/* ▼▼▼ [수정됨] 봇카드 읽기 기능을 제거한 단순 파일 처리 로직 ▼▼▼ */
async function processBatchFiles(files) {
    if (!files || files.length === 0) return;

    showMessage(`${files.length}개의 파일을 분석 중입니다...`);
    let combinedText = "";
    let collectedImages = [];

    for (const file of files) {
        const isImage = file.type.startsWith('image/');
        
        if (isImage) {
            // 모든 이미지는 JPEG로 최적화하여 AI 분석용으로 수집
            await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width; canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#FFFFFF'; 
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        collectedImages.push(canvas.toDataURL('image/jpeg', 0.9));
                        resolve();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        } else {
            // 텍스트/JSON 파일 내용 추출
            await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    combinedText += `\n\n[파일: ${file.name}]\n${e.target.result}\n`;
                    resolve();
                };
                reader.readAsText(file);
            });
        }
    }

    if (combinedText.trim() !== "" || collectedImages.length > 0) {
        const id = Date.now().toString();
        const mainTitle = files[0].name.split('.')[0];
        const newChat = { 
            id, title: mainTitle, 
            worldId: 'novel_mode_dummy', 
            characterIds: [], history: [], memory: '',
            isNovelMode: true, 
            novelContent: combinedText.trim(), 
            novelImages: collectedImages 
        };
        DB.chats.unshift(newChat);
        saveData();
        renderSidebar();
        loadSession(id);
        showMessage("파일 업로드 완료");
    }
}


        function getWorldIcon(world) {
            const text = (world.genre || '') + ' ' + (world.name || '') + ' ' + (world.description || '');
            if(text.match(/판타지|이세계|마법|드래곤|영주|귀족/)) return 'fa-dungeon';
            if(text.match(/학원|학교|아카데미|학생|교사/)) return 'fa-school';
            if(text.match(/무협|동양|천마|무림|선협/)) return 'fa-scroll';
            if(text.match(/SF|우주|미래|사이버|로봇/)) return 'fa-robot';
            if(text.match(/현대|일상|회사|도시|오피스/)) return 'fa-building';
            if(text.match(/아포칼립스|좀비|생존|멸망|바이러스/)) return 'fa-biohazard';
            return 'fa-globe';
        }


function updateSidebarButtons(tab) {
            const btn1 = document.getElementById('ai-create-btn');
            const btn2 = document.getElementById('manual-create-btn');
            
            // 외부 검색 버튼들 (존재 여부 체크 후 숨김 처리)
            const extBtns = [
                document.getElementById('external-char-create-btn'),
                document.getElementById('external-user-create-btn'),
                document.getElementById('external-world-create-btn')
            ];
            extBtns.forEach(b => { if(b) b.classList.add('hidden'); });


            if (!btn1 || !btn2) return; // 버튼이 없으면 중단


            if (tab === 'chats') {
                // 라이브러리(채팅 목록) 탭일 때: '새 이야기 시작' 버튼으로 변경
                btn1.innerHTML = '<i class="fa-solid fa-plus"></i> 새 이야기 시작';
                btn1.onclick = () => openSessionSettings('new'); // 클릭 이벤트 재할당
                btn1.classList.remove('hidden');
                
                btn2.classList.add('hidden'); // 직접 입력 버튼 숨김
            } else {
                // 배경/캐릭터 탭일 때: AI 생성 및 직접 입력 버튼 활성화
                btn2.classList.remove('hidden');
                const label = tab === 'users' ? '유저 페르소나' : (tab === 'worlds' ? '배경' : '캐릭터');
                
                // 탭별로 외부 검색 버튼 노출
                if (tab === 'chars' && extBtns[0]) extBtns[0].classList.remove('hidden');
                if (tab === 'users' && extBtns[1]) extBtns[1].classList.remove('hidden');
                if (tab === 'worlds' && extBtns[2]) extBtns[2].classList.remove('hidden');


                if (tab === 'users') {
                    btn1.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles"></i> AI 페르소나 생성`;
                } else if (tab === 'chars') {
                     btn1.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles"></i> AI 캐릭터 생성`;
                } else {
                    btn1.innerHTML = `<i class="fa-solid fa-wand-magic-sparkles"></i> AI로 ${label} 생성`;
                }
                
                // 클릭 이벤트 재할당 (중요)
                btn1.onclick = () => openAiGeneratorModal(tab);
                btn2.innerHTML = `<i class="fa-solid fa-pen-ruler"></i> ${label} 직접 입력`;
                btn2.onclick = () => openEditor(null, tab);
            }
        }


function renderSidebar() {
            // [중요] 사이드바 렌더링 시 버튼 상태 업데이트 호출
            updateSidebarButtons(AppState.currentTab);


            const openWorldIds = Array.from(document.querySelectorAll('.world-item.open')).map(el => el.dataset.id);
            
            if(AppState.currentTab === 'chats') {
                const p = document.getElementById('panel-chats'); p.innerHTML = '';
                DB.chats.forEach(c => {
                    let subText = c.lastMessage||'대화 없음';
                    let emoji = c.emoji;
                    if (c.isNovelMode) {
                        subText = '소설 모드 (' + c.novelContent.substring(0, 50).replace(/\n/g, ' ') + '...)';
                        emoji = '📖';
                    }


                    const itemHtml = `
                        <div class="flex justify-between items-center p-3 bg-white border rounded-lg hover:bg-gray-50 cursor-pointer group mb-2" onclick="loadSession('${c.id}')">
                            <div class="flex items-center overflow-hidden">
                                <div class="w-10 h-10 rounded bg-indigo-100 flex items-center justify-center text-xl mr-3 flex-shrink-0">${emoji || '  '}</div>
                                <div><div class="font-bold text-sm truncate">${c.title||'제목 없음'}</div><div class="text-xs text-gray-500 truncate">${subText}</div></div>
                            </div>
                            <button onclick="event.stopPropagation(); deleteChat('${c.id}')" class="p-2 text-gray-400 hover:text-red-500"><i class="fa-solid fa-trash-can"></i></button>
                        </div>`;
                    p.innerHTML += itemHtml;
                });
            } else if(AppState.currentTab === 'worlds') {
                // ... (기존 worlds 렌더링 코드 유지) ...
                const p = document.getElementById('panel-worlds'); p.innerHTML = '';
                DB.worlds.forEach(w => {
                    const iconClass = getWorldIcon(w);
                    const iconDisplay = w.emoji 
                        ? `<div class="w-10 h-10 rounded bg-indigo-100 flex items-center justify-center text-2xl mr-3 flex-shrink-0">${w.emoji}</div>`
                        : `<div class="w-10 h-10 rounded bg-indigo-100 flex items-center justify-center text-indigo-500 mr-3 flex-shrink-0"><i class="fa-solid ${iconClass}"></i></div>`;


                    const charsHtml = (w.characters||[]).map(c => `
                        <div class="flex justify-between p-2 hover:bg-indigo-50 rounded cursor-pointer" onclick="event.stopPropagation(); openEditor('${c.id}','chars', null, '${w.id}')">
                            <div class="flex items-center"><i class="fa-solid fa-user mr-2 text-gray-400"></i><span class="text-sm">${c.name}</span></div>
                            <button onclick="event.stopPropagation(); deleteChar('${w.id}','${c.id}')" class="text-gray-400 hover:text-red-500"><i class="fa-solid fa-times"></i></button>
                        </div>`).join('');
                    
                    const user = w.user;
                    let userBtnHtml = '';
                    if (user && user.name) {
                        userBtnHtml = `
                        <div class="flex justify-between p-2 hover:bg-indigo-50 rounded cursor-pointer mb-1" onclick="event.stopPropagation(); openEditor(null, 'users', null, '${w.id}')">
                             <div class="flex items-center"><i class="fa-solid fa-user-astronaut mr-2 text-indigo-500"></i><span class="text-sm font-bold">${user.name} (유저)</span></div>
                             <button onclick="event.stopPropagation(); deleteUser('${w.id}')" class="text-gray-400 hover:text-red-500"><i class="fa-solid fa-times"></i></button>
                        </div>`;
                    } else {
                        userBtnHtml = `
                            <div class="flex gap-1 mb-2">
                                <button onclick="event.stopPropagation(); openAiGeneratorModal('creative_user', '${w.id}')" class="flex-1 py-1.5 bg-purple-100 text-purple-700 text-xs rounded font-bold hover:bg-purple-200"><i class="fa-solid fa-search"></i> 창작물 검색</button>
                                <button onclick="event.stopPropagation(); openAiGeneratorModal('users', '${w.id}')" class="flex-1 py-1.5 bg-indigo-100 text-indigo-700 text-xs rounded font-bold hover:bg-indigo-200"><i class="fa-solid fa-wand-magic-sparkles"></i> AI 생성</button>
                                <button onclick="event.stopPropagation(); openEditor(null, 'users', null, '${w.id}')" class="flex-1 py-1.5 bg-gray-100 text-gray-700 text-xs rounded font-bold hover:bg-gray-200"><i class="fa-solid fa-pen-ruler"></i> 직접 입력</button>
                            </div>`;
                    }


                    p.innerHTML += `
                        <div class="world-item mb-2" data-id="${w.id}">
                            <div class="world-header flex justify-between items-center p-3 border border-gray-200 rounded-lg bg-white hover:bg-gray-50 cursor-pointer gap-2" onclick="this.parentElement.classList.toggle('open')">
                                <div class="flex items-center flex-1 min-w-0 overflow-hidden">
                                    ${iconDisplay}
                                    <span class="font-bold text-sm truncate">${w.name}</span>
                                </div>
                                <div class="flex items-center flex-shrink-0">
                                    <button onclick="event.stopPropagation(); openEditor('${w.id}','worlds')" class="p-2 text-gray-400 hover:text-indigo-600 transition" title="배경 수정"><i class="fa-solid fa-gear"></i></button>
                                    <button onclick="event.stopPropagation(); deleteWorld('${w.id}')" class="p-2 text-gray-400 hover:text-red-500 transition" title="배경 삭제"><i class="fa-solid fa-trash-can"></i></button>
                                    <i class="fa-solid fa-chevron-down text-gray-400 p-2 ml-1 transition-transform duration-200"></i>
                                </div>
                            </div>
                            <div class="world-chars p-2 border border-t-0 border-gray-200 rounded-b-lg bg-white">
                                ${userBtnHtml}
                                ${charsHtml}
                                <div class="flex gap-1 mt-2">
                                     <button onclick="event.stopPropagation(); openAiGeneratorModal('creative_char', '${w.id}')" class="flex-1 py-1.5 bg-purple-100 text-purple-700 text-xs rounded font-bold hover:bg-purple-200"><i class="fa-solid fa-search"></i> 창작물 검색</button>
                                    <button onclick="event.stopPropagation(); openAiGeneratorModal('chars', '${w.id}')" class="flex-1 py-1.5 bg-indigo-100 text-indigo-600 text-xs rounded font-bold hover:bg-indigo-200"><i class="fa-solid fa-wand-magic-sparkles"></i> AI 생성</button>
                                    <button onclick="event.stopPropagation(); openEditor(null, 'chars', null, '${w.id}')" class="flex-1 py-1.5 bg-gray-100 text-gray-600 text-xs rounded font-bold hover:bg-gray-200"><i class="fa-solid fa-pen-ruler"></i> 직접 입력</button>
                                </div>
                            </div>
                        </div>`;
                });
                
                openWorldIds.forEach(id => {
                    const item = p.querySelector(`.world-item[data-id="${id}"]`);
                    if(item) item.classList.add('open');
                });
            }
        }


/* --- [수정됨] 입력창 높이가 확장된 에디터 함수 --- */
function openEditor(id, type, prefillData = null, worldId = null) {
    const body = document.getElementById('modal-body');
    let data = prefillData;


    // 데이터 로드 로직
    if (id) {
        if (type === 'chars') DB.worlds.forEach(w => { const c = w.characters?.find(x => x.id === id); if(c) data = c; });
        else if (type === 'worlds') data = DB.worlds.find(x => x.id === id);
    } else if (!prefillData) {
        if (type === 'worlds') { data = { aiRules: [], lorebook: [] }; }
        if (type === 'users' && worldId) { const w = DB.worlds.find(x => x.id === worldId); if(w && w.user) data = w.user; else data = { entries: [] }; }
        if (type === 'chars') { data = { entries: [], lorebook: [] }; }
    } else {
        if(data.aiRules) data.aiRules = data.aiRules.filter(r => r.title || r.content);
        if(data.lorebook) data.lorebook = data.lorebook.filter(r => r.title || r.content);
        if(data.entries) data.entries = data.entries.filter(r => r.title || r.content);
    }
    
    // HTML 헬퍼 함수들
    const escapeHtml = (str) => String(str||'').replace(/"/g, '&quot;');
    const ipt = (lbl, key, val) => `<div><label class="block text-xs font-bold text-gray-600 mb-1">${lbl}</label><input type="text" data-key="${key}" value="${escapeHtml(val)}" class="w-full p-2 border rounded bg-white text-sm focus:ring-1 focus:ring-indigo-500"></div>`;
    
    // [수정] txtGrid: 기본 rows를 2에서 3으로 소폭 상향
    const txtGrid = (lbl, key, val) => `<div class="col-span-1"><label class="block text-[11px] font-bold text-gray-500 mb-0.5 truncate" title="${lbl}">${lbl}</label><textarea data-key="${key}" rows="3" class="w-full p-1.5 border rounded bg-white text-xs leading-tight focus:ring-1 focus:ring-indigo-500 resize-none">${escapeHtml(val)}</textarea></div>`;
    
    const txt = (lbl, key, val, rows=3, placeholder='') => `<div class="col-span-1"><label class="block text-xs font-bold text-gray-600 mb-1">${lbl}</label><textarea data-key="${key}" rows="${rows}" class="w-full p-2 border rounded bg-white text-sm leading-relaxed focus:ring-1 focus:ring-indigo-500" placeholder="${placeholder}">${escapeHtml(val)}</textarea></div>`;
    const txtFull = (lbl, key, val, rows=4, placeholder='') => `<div class="col-span-1 md:col-span-2 lg:col-span-3"><label class="block text-xs font-bold text-gray-600 mb-1">${lbl}</label><textarea data-key="${key}" rows="${rows}" class="w-full p-2 border rounded bg-white text-sm leading-relaxed focus:ring-1 focus:ring-indigo-500" placeholder="${placeholder}">${escapeHtml(val)}</textarea></div>`;


    let html = `<input type="hidden" id="edit-id" value="${id||''}"><input type="hidden" id="edit-type" value="${type}">`;
    if(worldId) html += `<input type="hidden" id="edit-world-id" value="${worldId}">`;


    if (type === 'chars') {
        html += `
        <div class="flex border-b mb-4 text-sm font-medium overflow-x-auto">
            <button class="editor-tab-btn active shrink-0" onclick="switchEditorTab('basic')">기본/외형</button>
            <button class="editor-tab-btn shrink-0" onclick="switchEditorTab('sexual')">성적 취향</button>
            <button class="editor-tab-btn shrink-0" onclick="switchEditorTab('depth')">심화/내면</button>
            <button class="editor-tab-btn shrink-0" onclick="switchEditorTab('extra')">기타 설정</button>
        </div>
        
        <div id="edit-tab-basic" class="space-y-4">
            <div class="grid grid-cols-2 gap-3">
                ${ipt('이름', 'name', data?.name)}
                ${ipt('원작 작품명', 'source_material', data?.source_material)}
            </div>
            <div class="grid grid-cols-3 gap-2">
                ${txtGrid('성별', 'gender', data?.gender)}
                ${txtGrid('나이', 'age', data?.age)}
                ${txtGrid('종족', 'race', data?.race)}
                ${txtGrid('신장', 'height', data?.height)}
                ${txtGrid('체중', 'weight', data?.weight)}
                ${txtGrid('피부색', 'skin', data?.skin)}
            </div>
            <div class="p-3 bg-gray-50 border rounded-lg">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    ${ipt('체형/몸매', 'body_type', data?.body_type)}
                    ${ipt('쓰리사이즈', 'three_sizes', data?.three_sizes)}
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                    ${txtGrid('헤어 스타일', 'hair_style', data?.hair_style)} 
                    ${txtGrid('눈매/눈동자', 'eyes', data?.eyes)}
                    ${txtGrid('직업/역할', 'job', data?.job)}
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                <div class="md:row-span-2">
                    ${txt('외모 묘사', 'appearance_desc', data?.appearance_desc, 12)}
                </div>
                <div class="grid grid-cols-1 gap-2 content-start">
                    <label class="block text-xs font-bold text-gray-600">특징 태그 (콤마로 구분)</label>
                    ${txtGrid('액세서리/문신/피어싱', 'accessories', data?.accessories)}
                    ${txtGrid('성격 태그', 'personality_tags', data?.personality_tags)}
                    ${txtGrid('말투/목소리 특징', 'voice', data?.voice)}
                    ${txtGrid('정신 상태/멘탈', 'mental_state', data?.mental_state)}
                </div>
            </div>
            ${txtFull('샘플 대사 (상황별 줄바꿈)', 'sample_dialogue', data?.sample_dialogue, 6)}
        </div>


        <div id="edit-tab-sexual" class="hidden space-y-4">
            <div class="grid grid-cols-2 gap-3">
                ${txtGrid('성감대', 'erogenous_zones', data?.erogenous_zones)}
                ${txtGrid('페티시', 'fetish', data?.fetish)}
                ${txtGrid('속옷 스타일', 'underwear', data?.underwear)}
                ${txtGrid('음모/털 상태', 'pubic_hair', data?.pubic_hair)}
                
                <div class="col-span-2">
                    <label class="block text-xs font-bold text-gray-600 mb-1">성적 성향/특성 (상세)</label>
                    <textarea data-key="perverted_features" rows="6" class="w-full p-2 border rounded bg-white text-sm leading-relaxed focus:ring-1 focus:ring-indigo-500 shadow-sm">${escapeHtml(data?.perverted_features)}</textarea>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-2">* 더 자세한 심리 묘사는 '심화/내면' 탭을 이용하세요.</p>
        </div>


        <div id="edit-tab-depth" class="hidden space-y-4">
            <div class="bg-indigo-50 p-3 rounded text-xs text-indigo-700 mb-2 border border-indigo-100">
                <i class="fa-solid fa-info-circle mr-1"></i> 이 탭의 내용은 캐릭터의 입체적인 반응을 위해 AI에게 강력하게 주입됩니다.
            </div>
            
            ${txtFull('말투/어조 심화 가이드라인', 'dialogue_depth', data?.dialogue_depth, 6, '예: 당황하면 말을 더듬음, 성적인 상황에서 존댓말이 무너짐, 평소엔 냉철하지만 쾌락 앞에서는 혀가 꼬임 등')}
            ${txtFull('성적 반응 및 내면 심리 상세', 'sexual_psyche', data?.sexual_psyche, 8, '예: 겉으로는 거부하지만 속으로는 쾌락을 느낌, 모성애와 타락 사이의 갈등, 암살자의 본능이 성감으로 변질되는 과정 등')}
            ${txtFull('성적 상황 행동 패턴', 'sexual_behavior', data?.sexual_behavior, 6, '예: 처음에는 저항하다가 중반부터 적극적으로 변함, 절정 시에는 아헤가오와 함께 이성을 잃음 등')}
        </div>


        <div id="edit-tab-extra" class="hidden space-y-4">
            ${renderEntriesEditor(data?.entries, '기타 상세 설정 (Entries)', 'entries')}
        </div>
        `;
    } else if (type === 'users') {
        html += `
        <h4 class="font-bold text-indigo-700 mb-3">유저 페르소나 설정</h4>
        
        <div class="grid grid-cols-3 gap-3 mb-4">
            ${ipt('이름', 'name', data?.name)}
            ${txtGrid('성별', 'gender', data?.gender || '남성')}
            ${txtGrid('나이', 'age', data?.age)}
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            ${txt('외모/스타일', 'outfit', data?.outfit, 4)}
            ${txt('신체적 특징', 'features', data?.features, 4)}
        </div>
        <div class="mb-4">${txtFull('취미/특기/배경', 'hobbies', data?.hobbies, 4)}</div>
        ${txtFull('샘플 대사', 'sample_dialogue', data?.sample_dialogue, 6)}
        ${renderEntriesEditor(data?.entries, '추가 설정', 'entries')}
        `;
    } else if (type === 'worlds') {
        html += `<div class="mb-4">${ipt('제목', 'name', data?.name)}</div>`;
        html += `<div class="mb-4">${txtFull('설명', 'description', data?.description, 10)}</div>`;
        html += renderEntriesEditor(data?.aiRules, 'AI 연출 지침', 'aiRules');
        html += renderEntriesEditor(data?.lorebook, '배경 로어북', 'lorebook', true);
    }


    body.innerHTML = html;
    document.getElementById('modal-title').innerText = id ? '수정' : '새로 만들기';
    document.getElementById('modal-delete-btn').classList.toggle('hidden', !id);
    
    const genDetailsBtn = document.getElementById('btn-gen-details');
    if(genDetailsBtn) genDetailsBtn.classList.toggle('hidden', !data?.name); 


    openModalInternal('editor-modal');




    // 모달이 열린 직후, 내부의 모든 textarea에 드래그 핸들을 부착합니다.
    setTimeout(() => {
        const textareas = document.querySelectorAll('#modal-body textarea');
        textareas.forEach(el => makeResizable(el));
    }, 50);




    // 저장 로직
    document.getElementById('modal-save-btn').onclick = () => {
        const newItem = data || { id: Date.now().toString() };
        if (!id && type !== 'users') newItem.id = Date.now().toString();
        
        body.querySelectorAll('input[data-key], textarea[data-key]').forEach(el => newItem[el.dataset.key] = el.value);
        
        body.querySelectorAll('.entries-container').forEach(cont => {
            const key = cont.dataset.key;
            const entries = [];
            cont.querySelectorAll('.entry-item').forEach(item => {
                const title = item.querySelector('.ent-title').value;
                const content = item.querySelector('.ent-content').value;
                if(title || content) { 
                    entries.push({
                        title: title,
                        content: content,
                        keywords: item.querySelector('.ent-keys')?.value || '',
                        enabled: item.querySelector('.ent-enable').checked
                    });
                }
            });
            newItem[key] = entries;
        });


        if (type === 'worlds') {
            const idx = DB.worlds.findIndex(x=>x.id === newItem.id);
            if(idx >= 0) DB.worlds[idx] = newItem; else DB.worlds.push(newItem);
        } else if (type === 'users') {
            const w = DB.worlds.find(x => x.id === worldId);
            if(w) w.user = newItem;
        } else if (type === 'chars') {
            const w = DB.worlds.find(x => x.id === worldId);
            if(w) {
                if(!w.characters) w.characters = [];
                const idx = w.characters.findIndex(c=>c.id === newItem.id);
                if(idx >= 0) w.characters[idx] = newItem; else w.characters.push(newItem);
            }
        }
        saveData(); renderSidebar(); closeModal('editor-modal');
    };
    
    document.getElementById('modal-delete-btn').onclick = () => {
        if(confirm('삭제하시겠습니까?')) {
            if(type === 'worlds') DB.worlds = DB.worlds.filter(x=>x.id !== id);
            else if(type === 'chars') DB.worlds.forEach(w => { if(w.characters) w.characters = w.characters.filter(c=>c.id !== id); });
            saveData(); renderSidebar(); closeModal('editor-modal');
        }
    };
}


        window.switchEditorTab = (tab) => {
            document.querySelectorAll('.editor-tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            ['basic','sexual','depth','extra'].forEach(t => {
                const el = document.getElementById('edit-tab-'+t);
                if(el) el.classList.add('hidden');
            });
            const target = document.getElementById('edit-tab-'+tab);
            if(target) target.classList.remove('hidden');
        };
        
        window.switchGeneratorTab = (index) => {
            document.querySelectorAll('.generator-tab-btn').forEach((b, i) => {
                if(i === index) b.classList.add('active'); else b.classList.remove('active');
            });
            document.querySelectorAll('.gen-tab-content').forEach((d, i) => {
                if(i === index) d.classList.remove('hidden'); else d.classList.add('hidden');
            });
        };


        function renderEntriesEditor(entries = [], label, key, isLore=false) {
            const cleanEntries = (entries || []).filter(e => e.title || e.content);
            let html = `<div class="entries-container mt-4" data-key="${key}">
                <div class="flex justify-between items-center mb-2"><label class="font-bold text-sm text-gray-700">${label}</label><button onclick="addEntryRow(this, ${isLore})" class="text-xs bg-indigo-50 text-indigo-600 px-2 py-1 rounded">+ 추가</button></div>
                <div class="space-y-2 list-area">`;
            cleanEntries.forEach(e => { 
                html += `<div class="entry-item border rounded p-2 bg-gray-50 relative">
                    <div class="flex gap-2 mb-1">
                        <input class="ent-title flex-1 p-1 border text-xs" placeholder="제목" value="${String(e.title||'').replace(/"/g, '&quot;')}">
                        ${isLore ? `<input class="ent-keys flex-1 p-1 border text-xs" placeholder="키워드" value="${String(e.keywords||'').replace(/"/g, '&quot;')}">` : ''}
                        <input type="checkbox" class="ent-enable" ${e.enabled!==false?'checked':''}>
                        <button onclick="this.closest('.entry-item').remove()" class="text-red-500"><i class="fa-solid fa-times"></i></button>
                    </div>
                    <textarea class="ent-content w-full p-1 border text-xs h-16" placeholder="내용">${e.content||''}</textarea>
                </div>`;
            });
            html += `</div></div>`;
            return html;
        }
        window.addEntryRow = (btn, isLore) => {
            const area = btn.closest('.entries-container').querySelector('.list-area');
            const div = document.createElement('div');
            div.className = "entry-item border rounded p-2 bg-gray-50 relative";
            div.innerHTML = `<div class="flex gap-2 mb-1">
                <input class="ent-title flex-1 p-1 border text-xs" placeholder="제목">
                ${isLore ? `<input class="ent-keys flex-1 p-1 border text-xs" placeholder="키워드">` : ''}
                <input type="checkbox" class="ent-enable" checked>
                <button onclick="this.closest('.entry-item').remove()" class="text-red-500"><i class="fa-solid fa-times"></i></button>
            </div>
            <textarea class="ent-content w-full p-1 border text-xs h-16" placeholder="내용"></textarea>`;
            area.appendChild(div);
        };


        window.handleTagClick = (btn) => {
            const section = btn.closest('.gen-section');
            const isSingle = section.dataset.single === 'true';
            const tagValue = btn.innerText;


            if (isSingle) {
                Array.from(section.querySelectorAll('.keyword-tag')).forEach(c => {
                     if (c !== btn) c.classList.remove('active');
                });
            }
            btn.classList.toggle('active');


            if (section.id === 'race-section') {
                const beastSection = document.getElementById('beast-detail-section');
                if (beastSection) {
                    if (btn.classList.contains('active') && tagValue === '수인') {
                         beastSection.classList.add('show');
                         beastSection.classList.remove('hidden-section');
                    } else if (tagValue === '수인' && !btn.classList.contains('active')) {
                         beastSection.classList.remove('show');
                         beastSection.classList.add('hidden-section');
                         beastSection.querySelectorAll('.keyword-tag').forEach(b => b.classList.remove('active'));
                    } else if (isSingle && btn.classList.contains('active') && tagValue !== '수인') {
                         beastSection.classList.remove('show');
                         beastSection.classList.add('hidden-section');
                         beastSection.querySelectorAll('.keyword-tag').forEach(b => b.classList.remove('active'));
                    }
                }
            }
        };


        function openAiGeneratorModal(type, worldId=null) {
            window.genType = type; window.genWorldId = worldId;
            const modal = document.getElementById('ai-generator-modal');
            const body = document.getElementById('ai-generator-body'); 
            const tabsContainer = document.getElementById('ai-generator-tabs');
            
            tabsContainer.innerHTML = ''; 
            tabsContainer.classList.add('hidden');
            document.getElementById('btn-random-gen').classList.remove('hidden'); 


            const nsfwToggleHtml = `
                <label class="flex items-center gap-2 cursor-pointer bg-red-50 px-3 py-1 rounded-lg border border-red-100 hover:bg-red-100 transition ml-2">
                    <input type="checkbox" id="gen-nsfw-toggle" class="w-4 h-4 text-red-600 rounded focus:ring-red-500 border-gray-300" checked>
                    <span class="text-xs font-bold text-red-600">성인(NSFW) 모드</span>
                </label>
            `;


            const headerControls = document.querySelector('#ai-generator-modal .flex.items-center.gap-3');
            const existingToggle = document.getElementById('gen-nsfw-toggle-container');
            if(existingToggle) existingToggle.remove();
            
            const toggleContainer = document.createElement('div');
            toggleContainer.id = 'gen-nsfw-toggle-container';
            toggleContainer.innerHTML = nsfwToggleHtml;
            headerControls.appendChild(toggleContainer);


            if (type.startsWith('creative_')) {
                document.getElementById('btn-random-gen').classList.add('hidden'); 
                const label = type === 'creative_user' ? '유저 페르소나' : (type === 'creative_world' ? '배경' : '캐릭터'); 
                
                const placeholderWork = '예: 작품명 입력';
                const placeholderName = type === 'creative_world' ? '예: 배경 이름' : '예: 캐릭터 이름';
                
                let html = `
                <div class="space-y-4">
                    <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                        <h4 class="font-bold text-purple-700 mb-2"><i class="fa-solid fa-search mr-2"></i>웹 검색 기반 ${label} 생성</h4>
                        <p class="text-sm text-purple-600 mb-4">유명 창작물의 정보를 입력하면, AI가 웹 지식을 기반으로 설정을 자동 추출하여 작성합니다.</p>
                        
                        <label class="block text-sm font-bold text-gray-700 mb-1">창작물 이름 (작품명)</label>
                        <input type="text" id="creative-work-name" class="w-full p-2 border rounded mb-3 bg-white" placeholder="${placeholderWork}">
                `;
                
                if (type !== 'creative_world') {
                    html += `
                        <label class="block text-sm font-bold text-gray-700 mb-1">${label} 이름</label>
                        <input type="text" id="creative-char-name" class="w-full p-2 border rounded bg-white mb-3" placeholder="${placeholderName}">
                        
                        <!-- 성별 선택 삭제 (AI 자동 판단) -->
                        <div class="text-xs text-gray-500 mb-3"><i class="fa-solid fa-robot mr-1"></i>성별은 이름과 맥락에 따라 AI가 자동으로 판단합니다.</div>
                    `;
                } else {
                     html += `<p class="text-xs text-gray-500">* 배경 이름은 창작물 이름으로 자동 설정됩니다.</p>`;
                }
                
                html += `
                        <div class="mt-4 border-t border-purple-200 pt-3">
                            <label class="block text-sm font-bold text-gray-700 mb-1">추가 요구사항</label>
                            <textarea id="ai-prompt-extra" class="w-full p-2 border rounded bg-white text-sm" rows="2" placeholder="예: 원작보다 더 타락하게 만들어줘, 성격을 더 순종적으로 변경해줘"></textarea>
                        </div>
                    </div>
                </div>`;
                
                body.innerHTML = html;
                openModalInternal('ai-generator-modal');
                return;
            }


            const config = aiGeneratorConfig[type];
            if (!config) { alert('설정 오류: ' + type); return; }


            let html = '';
            const renderSection = (s) => `
                <div id="${s.id||''}" class="mb-3 gen-section ${s.hidden ? 'hidden-section' : ''}" data-level="${s.level||1}" data-single="${s.singleChoice}">
                    <h4 class="font-bold text-sm text-gray-700 mb-1">${s.title}</h4>
                    <div class="flex flex-wrap gap-2">
                        ${(s.tags||[]).map(t => `<button onclick="handleTagClick(this)" class="keyword-tag px-3 py-1 bg-white border rounded-full text-xs transition">${t}</button>`).join('')}
                    </div>
                </div>`;
            
            if(config.tabs) {
                tabsContainer.classList.remove('hidden');
                config.tabs.forEach((t, i) => {
                    tabsContainer.innerHTML += `<button class="generator-tab-btn ${i===0?'active':''}" onclick="switchGeneratorTab(${i})">${t.name}</button>`;
                    html += `<div class="gen-tab-content ${i===0?'':'hidden'} space-y-3 pb-4 border-b border-gray-200 mb-4">${t.sections.map(renderSection).join('')}</div>`;
                });
            } else if (config.sections) {
                html += `<div class="space-y-3 gen-tab-content pb-4 border-b border-gray-200 mb-4">${config.sections.map(renderSection).join('')}</div>`;
            }


            html += `
                <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                    <label class="block text-sm font-bold text-gray-700 mb-1"><i class="fa-solid fa-pen-to-square mr-1"></i>추가 요구사항</label>
                    <textarea id="ai-prompt-extra" class="w-full p-2 border rounded bg-white text-sm focus:ring-2 focus:ring-indigo-500 focus:outline-none" rows="2" placeholder="선택한 키워드 외에 특별히 원하는 설정을 적어주세요."></textarea>
                </div>
            `;
            
            body.innerHTML = html;
            openModalInternal('ai-generator-modal');
        }


        function randomizeTab() {
            const activeTab = document.querySelector('.gen-tab-content:not(.hidden)');
            if(!activeTab) return;


            const raceSection = activeTab.querySelector('#race-section');
            let selectedRace = null;


            if (raceSection) {
                const buttons = Array.from(raceSection.querySelectorAll('.keyword-tag'));
                buttons.forEach(b => b.classList.remove('active')); 
                
                const choice = buttons[Math.floor(Math.random() * buttons.length)];
                choice.classList.add('active');
                selectedRace = choice.innerText;


                handleTagClick(choice);
            }


            const sections = activeTab.querySelectorAll('.gen-section');
            sections.forEach(sec => {
                if (sec.id === 'race-section') return; 


                const level = parseInt(sec.dataset.level || 1);
                const buttons = Array.from(sec.querySelectorAll('.keyword-tag'));
                
                buttons.forEach(b => b.classList.remove('active'));


                if (sec.id === 'beast-detail-section') {
                    if (selectedRace === '수인') {
                        const choice = buttons[Math.floor(Math.random() * buttons.length)];
                        choice.classList.add('active');
                    }
                    return; 
                }


                let prob = 1.0; 
                if (level === 2) prob = 0.8;
                else if (level === 3) prob = 0.4;


                if (Math.random() < prob && buttons.length > 0) {
                    const choice = buttons[Math.floor(Math.random() * buttons.length)];
                    choice.classList.add('active');
                }
            });
        }


        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }


async function handleGenerateClick() {
    // [수정됨] 공급자에 따라 적절한 API 키가 있는지 체크합니다.
    const isGemini = (SETTINGS.aiProvider || 'gemini') === 'gemini';
    const hasKey = isGemini ? SETTINGS.apiKey : SETTINGS.customApiKey;
    if(!hasKey) return alert(isGemini ? 'Gemini API 키를 설정해주세요.' : 'OpenRouter/OpenAI API 키를 설정해주세요.');
    
    const type = window.genType;

    const extra = document.getElementById('ai-prompt-extra') ? document.getElementById('ai-prompt-extra').value : '';
    const isNSFW = document.getElementById('gen-nsfw-toggle')?.checked;

    let tags = '';
    if (!type.startsWith('creative_')) {
        tags = Array.from(document.querySelectorAll('.keyword-tag.active')).map(el => el.innerText).join(', ');
    }

    document.getElementById('modal-loading-overlay-ai').classList.remove('hidden');
    document.getElementById('modal-loading-overlay-ai').classList.add('flex');
    document.getElementById('ai-retry-msg').classList.add('hidden');
    document.getElementById('ai-error-msg').classList.add('hidden');
    
    AppState.isGenerating = true; 
    if (AppState.abortController) AppState.abortController.abort();
    AppState.abortController = new AbortController();

    const startTime = Date.now();
    const timeDisplay = document.getElementById('ai-progress-time');
    timeDisplay.classList.remove('hidden');
    
    let intervalId = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        timeDisplay.innerText = `${elapsed}초 경과`;
    }, 1000);
    
    const ageUnknown = tags.includes('나이 미상');
    let ageRule = `Rule 3: For 'age', 'height', 'weight', use ARABIC NUMERALS.`;
    if (ageUnknown) {
        ageRule = `Rule 3: For 'height', 'weight' use ARABIC NUMERALS. HOWEVER, for 'age', MUST output string "미상" (Unknown).`;
    }


    let prompt = `You are a system creating a JSON profile for a Novel.
    Rule 1: Output VALID JSON ONLY. No Markdown. No intro/outro text.
    Rule 2: [IMPORTANT] The main content MUST be in KOREAN (한국어). HOWEVER, for "Names" (character/user name), follow the source material's context (KOREAN SCRIPT / e.g., "Alice" -> "앨리스").
    ${ageRule}
    Rule 4: 'three_sizes' should be formatted like "90-60-90" (Numbers).
    Rule 5: 'sample_dialogue' MUST use \\n for newlines.
    Rule 6: [CRITICAL] Escape all double quotes inside string values.
    
    Selected Tags: ${tags}.
    Extra Instructions: ${extra}.
    
    Constraint: 성감대(erogenous_zones)와 페티시(fetish)는 1개만 작성한다.
    Constraint: 상세 설정(entries) 외에도 'dialogue_depth'(말투 심화), 'sexual_psyche'(성적 심리), 'sexual_behavior'(성적 행동) 필드를 풍부하게 작성할 것.
    Constraint: [IMPORTANT] Provide AT LEAST 5 distinct lines for 'sample_dialogue' to fully showcase personality.
    `;
    
    // [수정] 생성용 NSFW 가이드라인 (에로/헨타이 포커스)
    if (isNSFW) {
        prompt += `\n[WARNING: R-18 Hentai/Ero Generation Mode]
    1. **Genre**: Hentai, Eroge, Adult content. (NOT Dark/Hardcore/Gore).
    2. **Tone**: Focus on 'Physical Pleasure', 'Sexual Excitement', and 'High Sensitivity' (Ahegao style).
    3. **Characterization**: 
       - Describe 'sexual_psyche' as melting/succumbing to pleasure, NOT feeling pain or deep trauma.
       - Highlight the contrast between their social persona and their lewd instincts (Gap Moe).
    4. **Constraint**: Do NOT include extreme violence, gore, or depressing themes. Focus on arousal and eroticism.`;
    } else {
        prompt += `\nIMPORTANT: Keep it Safe For Work (SFW). Focus on personality and story traits. Do NOT include explicit sexual descriptions.`;
    }


    if (tags.includes('성에 무지함')) {
            prompt += `\nIMPORTANT: Character is COMPLETELY IGNORANT about sex/pregnancy.`;
    }


    if (tags.includes('수인') || tags.includes('Beastkin')) {
        prompt += `\nConstraint: [CRITICAL] For '수인' (Beastkin), the character MUST look like a beautiful HUMAN with animal ears/tail (Kemonomimi style). STRICTLY NO Furry, NO Anthro faces. The face must be human.`;
    }


    // (이하 로직은 기존과 동일)
    if (type === 'worlds') {
        const isHeavy = tags.includes('아포칼립스') || tags.includes('헌터물') || tags.includes('디스토피아') || tags.includes('시리어스');
        if (!isHeavy) prompt += `\nConstraint: Create a world matching the genre. Focus on the specific mood selected.\n`;
        
        if (tags.includes('정조역전') || tags.includes('남녀역전')) {
            prompt += `\n[SPECIAL GENRE: REVERSE CHASTITY (정조역전)]
            1. World Concept: Common sense of gender sexuality is completely REVERSED. Women are aggressive, lustful predators. Men are chaste, conservative, and protected.
            2. Male Value: Men are rare or physically weaker, making them highly valuable. A "virgin male" is a national treasure.
            3. Protagonist (User): He is a 'Normal' man from Earth or simply open-minded. Just by doing basic things (paying for dinner, opening doors, smiling), women are overwhelmingly touched and fall in love (Healing/Pampering atmosphere).
            4. Atmosphere: Not just porn, but a 'Healing Harem' where the protagonist is pampered by powerful/rich women.`;
        }
    }


    if (type.startsWith('creative_')) {
        const workName = document.getElementById('creative-work-name').value;
        const charName = document.getElementById('creative-char-name') ? document.getElementById('creative-char-name').value : workName;
        const targetName = type === 'creative_world' ? workName : charName;
        
        let genderInstruction = "Gender: Determine automatically based on the name/role/context. If ambiguous, choose the most likely gender.";
        let structureGender = "Determine by context"; 


        prompt += `
        Task: Generate a profile for "${targetName}" from the work "${workName}".
        ${genderInstruction}
        Extra User Instructions: ${extra} (Must be prioritized)
        
        Constraint: If age is unknown, set to "미상".
        Constraint: 'sample_dialogue' MUST use actual lines from the original work. Provide 5+ lines.
        Constraint: 상세 설정(entries) 작성 시, 캐릭터의 개성이 드러나게 인간관계, 겪은 사건, 특징, 말투 등을 최대한 상세하게 작성할 것.        `;
        
        // 창작물 검색 시에도 톤 매너 유지
        if(isNSFW) {
             prompt += `IMPORTANT: Reinterpret the character with the 'Hentai/Eroge' tone defined above. Focus on their hidden desires or how they would react in an erotic situation, while keeping their original speech patterns.`;
        }


        if (type === 'creative_user') {
                prompt += `Type: User Persona. Output Structure: { name: "${targetName}", age, gender: "${structureGender}", hair_style, outfit, features, hobbies, sample_dialogue, entries: [{title: "Background", content: "..."}] }`;
        } else if (type === 'creative_world') {
                prompt += `Type: World. Output Structure: { name: "${workName}", genre: "Fantasy/SF/Modern etc", emoji: "One Emoji(  /  /etc)", description, aiRules:[{title, content}], lorebook:[{title, keywords, content}] }`;
        } else {
                prompt += `Type: Character.
                Output Structure: { name: "${targetName}", source_material: "${workName}", gender: "${structureGender}", age, race, skin, height, weight, three_sizes, body_type, hair_style, eyes, job, accessories, tattoo, appearance_desc, sample_dialogue, personality_tags, voice, perverted_features, mental_state, erogenous_zones, fetish, underwear, pubic_hair, dialogue_depth, sexual_psyche, sexual_behavior, entries: [{title: "Relations", content: "..."}] }`;
        }
} else if (type === 'chars') {
        const w = DB.worlds.find(x => x.id === window.genWorldId);
        // 로어북 내용 가져오기
        const worldLore = w ? (w.lorebook || []).map(l => `[World Lore: ${l.title}] ${l.content}`).join('\n') : '';


        let selectedGender = "여성"; 
        if(tags.includes("남성")) selectedGender = "남성";
        if(tags.includes("중성")) selectedGender = "중성";


        // [수정됨] worldLore 변수를 프롬프트에 실제로 삽입
        prompt += `Context World: "${w ? w.name : 'Unknown'}". 
        
        [World Context & Lore]
        ${worldLore}
        
        Task: Create a unique ${selectedGender} Character JSON based on the world context above.`;
        
        if(isNSFW) prompt += ` (Follow the R-18 Hentai guidelines).`;
        prompt += `Structure: { name, gender: "${selectedGender}", age, race, skin, height, weight, three_sizes, body_type, hair_style, eyes, job, accessories, tattoo, appearance_desc, sample_dialogue, personality_tags, voice, perverted_features, mental_state, erogenous_zones, fetish, underwear, pubic_hair, dialogue_depth, sexual_psyche, sexual_behavior, entries: [{title: "설정", content: "..."}] }`;
    } else if (type === 'users') {
        const w = DB.worlds.find(x => x.id === window.genWorldId);
        // 로어북 내용 가져오기
        const worldLore = w ? (w.lorebook || []).map(l => `[World Lore: ${l.title}] ${l.content}`).join('\n') : '';


        let selectedGender = "남성"; 
        if(tags.includes("여성")) selectedGender = "여성";
        if(tags.includes("중성")) selectedGender = "중성";


        // [수정됨] worldLore 변수를 프롬프트에 실제로 삽입
        prompt += `Context World: "${w ? w.name : 'Unknown'}".
        
        [World Context & Lore]
        ${worldLore}
        
        Task: Create a ${selectedGender} User Persona JSON suitable for this world.`;
        
        prompt += `Structure: { name, age, gender: "${selectedGender}", hair_style, outfit, features, hobbies, sample_dialogue, entries: [{title: "배경", content: "..."}] }`;
    }


// ▼▼▼ [여기] 아래 코드를 추가해 주세요 ▼▼▼
    else if (type === 'worlds') {
        prompt += `
        Task: Create a detailed World Setting JSON based on the selected tags.
        
        [Requirements]
        1. Name: A creative title for the world.
        2. Description: Detailed world introduction, atmosphere, and current situation (At least 300 characters).
        3. Rules(aiRules): 3~5 core rules that AI must follow in this world (e.g., "Magic requires blood", "Night is dangerous").
        4. Lorebook: 3~5 key setting elements (Locations, Factions, History).
        
        Output Structure: { name, genre, emoji, description, aiRules: [{title, content}], lorebook: [{title, keywords, content}] }
        `;
    }
    // ▲▲▲ [여기] 여기까지 추가 ▲▲▲


    const safetySettings = SETTINGS.uncensored 
        ? [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
            ]
        : [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_ONLY_HIGH" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_ONLY_HIGH" }
        ];


let retryCount = 0;
    const maxRetries = 3;
    let success = false;
    let finalData = null;

    while(retryCount < maxRetries && !success) {
        if (AppState.abortController.signal.aborted) break;

try {
            // [수정됨] 이제 requestAI 내부에서 공급자 분기를 처리하므로 안전합니다.
            let text = await AIEngine.requestAI(prompt, AppState.abortController.signal);
            text = text.replace(/```json/gi, '').replace(/```/g, '').trim();
/* --- (이하 동일하게 유지) --- */
            
            const firstBrace = text.indexOf('{');
            const lastBrace = text.lastIndexOf('}');
            
            if (firstBrace !== -1 && lastBrace !== -1) { 
                text = text.substring(firstBrace, lastBrace + 1);
            } else {
                throw new Error("올바른 JSON 형식을 찾을 수 없습니다.");
            }

            // JSON 파싱 (변수명 data 하나로 통일) [수정됨]
            let data = JSON.parse(text);

            // 구조 보정
            if (data.character) data = data.character;
            else if (data.user) data = data.user;
            else if (data.world) data = data.world;
            
            // 샘플 대사 정제
            if (data.sample_dialogue) {
                let lines = Array.isArray(data.sample_dialogue) ? data.sample_dialogue : data.sample_dialogue.split('\n');
                data.sample_dialogue = lines.map(l => l.trim()).filter(l => l).join('\n');
            }

            if(!data.entries) data.entries = [];
            finalData = data;
            success = true;

        } catch(e) { 
            if (e.name === 'AbortError') break;
            retryCount++;
            if(retryCount < maxRetries) await sleep(1500);
            else alert(`생성 실패: ${e.message}`);
        }
    }
    
    clearInterval(intervalId);
    AppState.isGenerating = false; 

    if(success && finalData) {
        document.getElementById('modal-loading-overlay-ai').classList.add('hidden');
        closeModal('ai-generator-modal');
        let editorType = (type === 'worlds' || type.startsWith('creative_world')) ? 'worlds' : (type === 'users' || type.startsWith('creative_user') ? 'users' : 'chars');
        openEditor(null, editorType, finalData, window.genWorldId);
    }
}

async function generateDetails() {
    // [수정됨] 공급자별 키 체크
    const isGemini = (SETTINGS.aiProvider || 'gemini') === 'gemini';
    const hasKey = isGemini ? SETTINGS.apiKey : SETTINGS.customApiKey;
    if(!hasKey) return alert('API 키를 설정해주세요.');
    
    const currentData = {};

    document.querySelectorAll('#modal-body input[data-key], #modal-body textarea[data-key]').forEach(el => currentData[el.dataset.key] = el.value);
    
    let activeTab = 'details';
    const activeBtn = document.querySelector('.editor-tab-btn.active');
    if (activeBtn) {
        if (activeBtn.innerText.includes('기본')) activeTab = 'basic';
        else if (activeBtn.innerText.includes('성적')) activeTab = 'sexual';
        else if (activeBtn.innerText.includes('심화')) activeTab = 'depth';
    }
    
    AppState.isDetailGenCancelled = false;
    if (AppState.abortController) AppState.abortController.abort();
    AppState.abortController = new AbortController();

    document.getElementById('modal-loading-overlay-details').classList.remove('hidden');
    document.getElementById('modal-loading-overlay-details').classList.add('flex');

    const prompt = `Generate detailed info in JSON... (중략) ... Current: ${JSON.stringify(currentData)}`;

try {
        let text = await AIEngine.requestAI(prompt, AppState.abortController.signal);

        text = text.replace(/\\(?!["\\/bfnrtu])/g, "");
        text = text.replace(/^```json\s*/i, '').replace(/^```\s*$/i, '').replace(/`/g, '').trim();
        
        const firstBrace = text.indexOf('{');
        const lastBrace = text.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1) { text = text.substring(firstBrace, lastBrace + 1); }

        let data = JSON.parse(text);
        if (data.character) data = data.character; 

        if(AppState.isDetailGenCancelled) return;

        // 데이터 적용 로직 (기존과 동일)
        if (activeTab === 'basic' || activeTab === 'sexual' || activeTab === 'depth') {
            Object.keys(data).forEach(key => {
                const input = document.querySelector(`[data-key="${key}"]`);
                if (input && (!input.value || input.value.length < 5)) input.value = data[key]; 
            });
        } else {
            // entries 및 lorebook 추가 로직...
        }
    } catch(e) { 
        if (e.name !== 'AbortError' && !AppState.isDetailGenCancelled) alert(e.message); 
    } finally { 
        document.getElementById('modal-loading-overlay-details').classList.add('hidden');
        document.getElementById('modal-loading-overlay-details').classList.remove('flex');
    }
}

function loadSession(id) {
            // 1. 타이핑 효과 초기화 (window 제거됨)
            if(AppState.typingTimer) {
                clearInterval(AppState.typingTimer);
                AppState.typingTimer = null;
            }
            AppState.typingQueue = [];
            AppState.isTyping = false;
            
            // 2. 세션 찾기
            AppState.sessionId = id;
            const s = DB.chats.find(c => c.id === id);

            // [안전장치] 혹시 세션을 못 찾았으면 중단
            if (!s) {
                console.error(`Session not found: ${id}`);
                return;
            }

            // 3. UI 초기화
            const p = document.getElementById('content-area');
            p.innerHTML = ''; 
            document.getElementById('header-title').innerText = s.title;
            document.getElementById('header-info').classList.remove('hidden');
            const inputArea = document.getElementById('input-area');
            if(inputArea) {
                inputArea.classList.remove('hidden'); 
                inputArea.classList.add('flex');
            }

            // ▼▼▼ [수정된 부분] s.AppState.isDirectorMode -> s.isDirectorMode 로 복구 ▼▼▼
            AppState.isDirectorMode = s.isDirectorMode || false; 
            
            // 4. 소설/RP 모드 구분 표시
            const infoWorld = document.getElementById('info-world');
            if (s.isNovelMode) {
                infoWorld.innerHTML = '<i class="fa-solid fa-book-open"></i> 소설 모드';
            } else {
                const w = DB.worlds.find(x => x.id === s.worldId);
                infoWorld.innerHTML = `<i class="fa-solid fa-globe"></i> ${w ? w.name : '-'}`;
            }

            // 5. 메시지 렌더링
            if(s.history) s.history.forEach((msg, i) => appendMessage(msg, false, i));
            
            renderRightSidebar(); 
            setTimeout(scrollToBottom, 50);
        }


function appendMessage(msg, animate = false, index = null) {
            const p = document.getElementById('content-area');
            if (p.querySelector('#empty-state')) p.innerHTML = '';

            // 1. 인덱스 자동 계산
            if (index === null && AppState.sessionId) {
                const chat = DB.chats.find(c => c.id === AppState.sessionId);
                index = chat ? chat.history.length - 1 : 0;
            }

            const isUser = msg.role === 'user';
            const isDirector = msg.role === 'director';

            // 2. 래퍼 생성
            const div = document.createElement('div');
            div.className = `msg-wrapper group ${isUser ? 'user' : (isDirector ? 'director' : 'model')} relative`;
            div.dataset.index = index;

            // 3. ★ 핵심: UIRenderer를 사용해 HTML 주입 ★
            div.innerHTML = UIRenderer.createMsgHTML(msg, index);
            p.appendChild(div);

            // 4. 텍스트 내용 채우기 및 효과 처리
            const contentDiv = div.querySelector(`#msg-content-${index}`);
            
if (animate) {
                 // (타이핑 효과 로직은 유지...)
                 if (!isUser && !isDirector) {
                    AppState.currentMsgElement = contentDiv;
                    TypingEngine.start(msg.text, contentDiv);
                 }
            } else {
                // (2) 로딩 시 (타이핑 없음)
                
                /* ▼▼▼ [수정] 유저 메시지는 마크다운 파싱 금지 (리스트 여백 문제 해결) ▼▼▼ */
                if (isUser) {
                    // 유저 메시지: 특수문자만 안전하게 처리하고 줄바꿈은 <br>로 단순 변환
                    const safeText = msg.text
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/\n/g, '<br>');
                        
                    contentDiv.innerHTML = safeText;
                } else {
                    // AI/Director 메시지: 기존대로 마크다운 적용 (굵게, 기울임 등 필요하므로)
contentDiv.innerHTML = marked.parse(msg.text, { 
                    breaks: true,
                    gfm: true 
                });
            }

                // 선택지 바로 표시
const choicesDiv = div.querySelector(`#choices-view-${index}`);
    if (choicesDiv) {
        // 기존 코드: choicesDiv.classList.remove('hidden', 'opacity-0');
        // 문제 원인: 이제 hidden 대신 max-h-0을 쓰므로, hidden만 지워서는 안 보임

        // 1. 숨김 해제 (높이 0 제거, 투명도 제거)
        choicesDiv.classList.remove('hidden', 'opacity-0', 'max-h-0');
        
        // 2. 모양 복구 (여백, 테두리, 높이 확보)
        // TypingEngine.stop에서 추가해주는 클래스들을 여기서도 똑같이 넣어줘야 함
        choicesDiv.classList.add('mt-4', 'pt-2', 'border-t', 'border-gray-200', 'max-h-[1000px]', 'opacity-100');
    }
            }

            // 5. 에디터 리사이즈 핸들 부착 (기능 연결)
            const textEditor = div.querySelector(`#text-editor-${index} textarea`);
            if (textEditor) makeResizable(textEditor);
            
            const choiceEditor = div.querySelector(`#choices-editor-${index} textarea`);
            if (choiceEditor) makeResizable(choiceEditor);
        }

// 선택지 클릭 시 실행되는 도우미 함수
function selectOption(text) {
    const input = document.getElementById('msg-input');
    if(input) {
        input.value = text; // 입력창에 텍스트 넣기
        sendMessage(text);  // 즉시 전송
    }
}


        
// [수정] 통합된 생성 취소 함수
function cancelGeneration() {
    // 1. 진행 중인 작업이 없다면 리턴
    if (!AppState.isGenerating) return;

    // 2. 진행 중인 요청 취소 (AbortController)
    if (AppState.abortController) {
        AppState.abortController.abort();
    }

    // 3. 타이핑 효과 중단 (채팅의 경우)
    if (AppState.typingTimer) {
        clearInterval(AppState.typingTimer);
        AppState.typingTimer = null;
    }
    AppState.typingQueue = [];

    // 4. 상태 플래그 초기화
    AppState.isGenerating = false;

    // 5. UI 복구 (채팅 버튼)
    updateSendButtonState('idle');

    // 6. UI 복구 (AI 생성 모달 로딩창)
    const modalOverlay = document.getElementById('modal-loading-overlay-ai');
    if (modalOverlay && !modalOverlay.classList.contains('hidden')) {
        modalOverlay.classList.add('hidden');
        modalOverlay.classList.remove('flex');
    }

    // 7. 안내 메시지
    showMessage('작업이 중단되었습니다.');
}


function openSessionSettings(mode='new') {
    // [수정] 들어오자마자 모드부터 확실하게 설정!
    AppState.isNewSessionMode = (mode === 'new'); 


    const chat = DB.chats.find(c => c.id === AppState.sessionId);


    // 이제 AppState.isNewSessionMode가 true이므로, 소설 모드여도 이 조건문에 걸리지 않고 통과합니다.
    if (!AppState.isNewSessionMode && chat && chat.isNovelMode) {
        return alert("소설 모드에서는 설정을 변경할 수 없습니다. 새 이야기 시작을 이용해 새로운 배경을 선택하세요.");
    }


    if(!DB.worlds.length && mode === 'new') return alert('먼저 배경을 생성하세요.');
            document.getElementById('session-modal-title').innerText = AppState.isNewSessionMode ? '새 이야기 시작' : '설정 변경';
            
            const listContainer = document.getElementById('world-selection-list');
            const fixedDisplay = document.getElementById('world-fixed-display');
            listContainer.innerHTML = '';


            if (AppState.isNewSessionMode) {
                listContainer.classList.remove('hidden');
                fixedDisplay.classList.add('hidden');
                DB.worlds.forEach(w => {
                    const btn = document.createElement('button');
                    const isSelected = AppState.worldId===w.id;
                    btn.className = `world-select-btn w-full text-left p-3 border rounded-lg hover:bg-indigo-50 ${isSelected ? 'selected' : ''}`;
                    btn.innerHTML = `<div class="font-bold text-sm">${w.name}</div><div class="text-xs text-gray-500 truncate">${w.description || '설정 없음'}</div>`;
                    btn.onclick = () => {
                        document.querySelectorAll('.world-select-btn').forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        AppState.worldId = w.id;
                        updateSessionChars(w.id);
                    };
                    listContainer.appendChild(btn);
                });
                
                // Initialize AppState.worldId if necessary
                if (!AppState.worldId && DB.worlds.length > 0) { 
                    AppState.worldId = DB.worlds[0].id; 
                    listContainer.firstChild?.classList.add('selected'); 
                    updateSessionChars(AppState.worldId); 
                } else if (AppState.worldId) {
                    updateSessionChars(AppState.worldId);
                }


            } else {
                listContainer.classList.add('hidden');
                fixedDisplay.classList.remove('hidden');
                if (chat) {
                    AppState.worldId = chat.worldId;
                    const w = DB.worlds.find(x => x.id === AppState.worldId);
                    fixedDisplay.innerHTML = `<i class="fa-solid fa-globe mr-2"></i>현재 배경: ${w ? w.name : 'Unknown'}`;
                    updateSessionChars(AppState.worldId, chat.characterIds);
                }
            }
            openModalInternal('session-modal');
        }


        function updateSessionChars(worldId, activeIds = null) {
            const w = DB.worlds.find(x=>x.id===worldId);
            const charArea = document.getElementById('session-chars');
            if (!w) {
                charArea.innerHTML = '<div class="text-gray-400 text-center text-sm mt-10">배경 정보가 유효하지 않습니다.</div>';
                return;
            }


            let html = '';
            if(w.user) { html += `<div class="p-2 border-b mb-2 bg-indigo-50 rounded"><i class="fa-solid fa-user-astronaut mr-2"></i><span class="font-bold">${w.user.name}</span> (유저)</div>`; }
            html += (w.characters||[]).map(c => {
                const isChecked = activeIds ? activeIds.includes(c.id) : true;
                return `<label class="flex items-center p-2 hover:bg-gray-100 cursor-pointer"><input type="checkbox" value="${c.id}" class="mr-2 w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500" ${isChecked ? 'checked' : ''}><span class="text-sm font-medium">${c.name}</span></label>`;
            }).join('');
            charArea.innerHTML = html;
        }


        function saveSessionSettings() {
            if(!AppState.worldId) return alert('배경을 선택하세요.');
            const cids = Array.from(document.querySelectorAll('#session-chars input:checked')).map(cb=>cb.value);
            if(AppState.isNewSessionMode) {
                const id = Date.now().toString();
                DB.chats.unshift({ id, title: '새로운 이야기', worldId: AppState.worldId, characterIds: cids, history: [], memory: '', isNovelMode: false });
                loadSession(id); 
            } else {
                if(AppState.sessionId) {
                    const s = DB.chats.find(c=>c.id===AppState.sessionId);
                    s.worldId = AppState.worldId; s.characterIds = cids;
                    
                    // Update header if settings change affected mode
                    const w = DB.worlds.find(x => x.id === s.worldId);
                    document.getElementById('info-world').innerHTML = `<i class="fa-solid fa-globe"></i> ${w ? w.name : '-'}`;
                    
                    showMessage('설정이 변경되었습니다.');
                }
            }
            saveData(); renderSidebar(); closeModal('session-modal');
        }
        
        function backupData() { const b = new Blob([JSON.stringify({DB,SETTINGS},null,2)],{type:'application/json'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download=`backup_${Date.now()}.json`; a.click(); }
        function loadBackup() { const i=document.createElement('input'); i.type='file'; i.onchange=e=>{ const r=new FileReader(); r.onload=v=>{ try{ const d=JSON.parse(v.target.result); if(d.DB){ localStorage.setItem(STORAGE_KEY,JSON.stringify(d.DB)); localStorage.setItem(SETTINGS_KEY,JSON.stringify(d.SETTINGS)); location.reload(); } }catch(err){ alert('Error'); } }; r.readAsText(e.target.files[0]); }; i.click(); }
        function importJSON(cb) { const i=document.createElement('input'); i.type='file'; i.onchange=e=>{ const r=new FileReader(); r.onload=v=>cb(JSON.parse(v.target.result)); r.readAsText(e.target.files[0]); }; i.click(); }
        
        function exportChat() { 
            if(!AppState.sessionId) return;
            const s = DB.chats.find(c=>c.id===AppState.sessionId);
            
            let txtContent = `제목: ${s.title}\n`;
            if (s.isNovelMode) {
                txtContent += `모드: 소설 모드 (원문 길이: ${s.novelContent.length})\n`;
            } else {
                txtContent += `배경: ${DB.worlds.find(w=>w.id===s.worldId)?.name || 'Unknown'}\n`;
            }
            txtContent += `장기 기억: ${s.memory || '없음'}\n\n`;
            
            s.history.forEach(msg => {
                const role = msg.role === 'user' ? '   User' : (msg.role === 'model' ? '   AI' : '   Director');
                txtContent += `[${role}]\n${msg.text}\n\n====================\n\n`;
            });
            // BOM 추가 (\uFEFF)로 모바일/윈도우 인코딩 깨짐 방지
            const b = new Blob(['\uFEFF' + txtContent], {type: 'text/plain;charset=utf-8'});
            const u = URL.createObjectURL(b);
            const a = document.createElement('a'); a.href = u; a.download = `${s.title}.txt`; a.click();
        }
        
        function deleteChat(id) { if(confirm('삭제?')) { DB.chats=DB.chats.filter(c=>c.id!==id); saveData(); renderSidebar(); if(AppState.sessionId===id) location.reload(); } }
        function deleteChar(wid, cid) { if(confirm('삭제?')) { const w=DB.worlds.find(x=>x.id===wid); w.characters=w.characters.filter(c=>c.id!==cid); saveData(); renderSidebar(); } }
        function deleteUser(wid) { if(confirm('유저 페르소나를 삭제하시겠습니까?')) { const w=DB.worlds.find(x=>x.id===wid); if(w) { delete w.user; saveData(); renderSidebar(); } } }
        function deleteWorld(id) { if(confirm('배경 및 연결된 캐릭터를 모두 삭제하시겠습니까?')) { DB.worlds = DB.worlds.filter(x=>x.id !== id); saveData(); renderSidebar(); } }
        
function clearChat() { 
    // 안내 메시지 수정 (10개 -> 2개)
    if(AppState.sessionId && confirm('대화 내역을 정리하시겠습니까?\n(최근 2개의 메시지만 남기고 이전 내역은 삭제됩니다.)')) { 
        const chat = DB.chats.find(c=>c.id===AppState.sessionId);
        // 조건 수정 (10 -> 2)
        if (chat.history.length > 2) { 
            // 자르기 수정 (-10 -> -2)
            chat.history = chat.history.slice(-2); 
            loadSession(AppState.sessionId); 
            saveData(); showMessage('대화가 정리되었습니다.');
        } else { showMessage('정리할 대화가 충분하지 않습니다.'); }
    } 
}

// ▼▼▼ [신규] 설정창 UI 전환 함수 ▼▼▼
function toggleProviderSettings() {
    const provider = document.getElementById('core-provider-select').value;
    if (provider === 'gemini') {
        document.getElementById('settings-group-gemini').classList.remove('hidden');
        document.getElementById('settings-group-openai').classList.add('hidden');
    } else {
        document.getElementById('settings-group-gemini').classList.add('hidden');
        document.getElementById('settings-group-openai').classList.remove('hidden');
    }
}
// ▲▲▲ [추가 끝] ▲▲▲
        
        function openCoreModal() { 
            document.getElementById('core-api-key').value = SETTINGS.apiKey;
            const modelKey = SETTINGS.currentModel || 'gemini-3-pro'; 
            document.getElementById('core-model-select').value = modelKey;
            document.getElementById('current-model-display').innerText = modelKey;
            
// ▼▼▼ [추가] 공급자 및 커스텀 설정 로드 ▼▼▼
    const provider = SETTINGS.aiProvider || 'gemini';
    document.getElementById('core-provider-select').value = provider;
    
    document.getElementById('core-custom-url').value = SETTINGS.customBaseUrl || 'https://openrouter.ai/api/v1';
    document.getElementById('core-custom-key').value = SETTINGS.customApiKey || '';
    document.getElementById('core-custom-model').value = SETTINGS.customModel || '';
    
    toggleProviderSettings(); // UI 상태 동기화
    // ▲▲▲ [추가 끝] ▲▲▲

            document.getElementById('core-safety-toggle').checked = SETTINGS.uncensored;
            document.getElementById('core-speed-select').value = SETTINGS.typingSpeed || 15;


/* ▼▼▼ [수정/추가] 토큰 슬라이더 위치 초기화 코드 ▼▼▼ */
            const currentTokens = SETTINGS.maxOutputTokens || 4000; // 저장된 값 없으면 4000
            document.getElementById('core-max-token-slider').value = currentTokens;
            document.getElementById('core-max-token-val').innerText = currentTokens;
            /* ▲▲▲ [여기까지] ▲▲▲ */
            
/* ... openCoreModal 함수 내부 ... */
            
            const fontSize = SETTINGS.fontSize || 16;
            document.getElementById('font-size-slider').value = fontSize;
            document.getElementById('font-size-val').innerText = fontSize + 'px';
            document.getElementById('font-preview-text').style.fontSize = (fontSize/16) + 'rem';
            
            // ▼▼▼ [삭제] 기존의 정적 요소 초기화 코드 3줄 삭제 ▼▼▼
            // document.getElementById('core-novel-point').value = ... 
            // document.getElementById('core-novel-style').value = ...
            // document.getElementById('core-novel-ratio').value = ...
            
// openCoreModal 함수 내부...
    
    // [수정] 설정 배열을 이용한 자동 렌더링
    const novelTab = document.getElementById('core-tab-novel');
    if (novelTab) {
        // 반복문을 통해 HTML 조립
        const dynamicSelects = NOVEL_SETTINGS_CONFIG.map(item => {
            const options = item.options.map(o => `<option value="${o}" ${SETTINGS[item.key]===o?'selected':''}>${o}</option>`).join('');
            return `
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-200 mb-1">${item.label}</label>
                <select id="sync-${item.key}" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100">
                    ${options}
                </select>
            </div>`;
        }).join('');


        novelTab.innerHTML = `
            <h4 class="font-bold text-gray-800 dark:text-white mb-4">소설 연출 상세 지침</h4>
            <div class="space-y-4">
                ${dynamicSelects}


                <div class="flex items-center justify-between p-3 bg-gray-100 dark:bg-slate-700 border border-gray-200 dark:border-slate-600 rounded-lg">
                    <label class="font-bold text-gray-700 dark:text-gray-200 text-sm"><i class="fa-solid fa-list-ol mr-1"></i>4지선다 선택지 자동 생성</label>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="core-multi-choice-toggle" class="sr-only peer" ${SETTINGS.enableMultiChoice ? 'checked' : ''}>
                        <div class="w-9 h-5 bg-gray-300 peer-focus:outline-none rounded-full peer dark:bg-slate-600 dark:border-slate-500 border border-gray-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>
            </div>
        `;
    }


            renderCoreRules(); renderDicRules(); 
            // ... (이후 코드 계속)
            
            renderCoreRules(); renderDicRules(); 


renderMacroSettings();


            openModalInternal('core-modal');






            // [모바일] 탭 동기화
            const mobileSelect = document.getElementById('core-tab-select-mobile');
            if (mobileSelect) {
                // Determine which tab is currently visible (default to 'api')
                let currentActiveTabId = 'api';
                const currentActiveBtn = document.querySelector('#core-modal-nav-desktop button.bg-indigo-50');
                if (currentActiveBtn) {
                     // Extract the value from onclick attribute or find it by iterating
                     const match = currentActiveBtn.onclick.toString().match(/switchCoreTab\(['"](.*?)['"]\)/);
                     if (match) currentActiveTabId = match[1];
                }
                
                // If the modal just opened, ensure 'api' is the default visual tab 
                // and sync the mobile select box.
                switchCoreTab(currentActiveTabId);
                mobileSelect.value = currentActiveTabId;
            } else {
                // Desktop: explicitly show the first tab and highlight the button
                switchCoreTab('api');
            }
        }




        
        document.getElementById('font-size-slider').addEventListener('input', function(e) {
            const size = e.target.value;
            document.getElementById('font-size-val').innerText = size + 'px';
            document.getElementById('font-preview-text').style.fontSize = (size/16) + 'rem';
            applyFontSize(size);
        });


        function applyFontSize(px) { document.documentElement.style.setProperty('--novel-font-size', (px/16) + 'rem'); }


function saveCoreSettings() { 
    try {
        // UI에서 값 가져오기
        SETTINGS.aiProvider = document.getElementById('core-provider-select').value;
        SETTINGS.apiKey = document.getElementById('core-api-key').value.trim();
        SETTINGS.currentModel = document.getElementById('core-model-select').value;

        // OpenAI/OpenRouter 설정 저장
        SETTINGS.customBaseUrl = document.getElementById('core-custom-url').value.trim();
        SETTINGS.customApiKey = document.getElementById('core-custom-key').value.trim(); 
        SETTINGS.customModel = document.getElementById('core-custom-model').value.trim();

        // 기타 공통 설정
        SETTINGS.uncensored = document.getElementById('core-safety-toggle').checked;
SETTINGS.typingSpeed = Number(document.getElementById('core-speed-select').value) || 15;
        SETTINGS.maxOutputTokens = Number(document.getElementById('core-max-token-slider').value) || 4000;
        // 실제 LocalStorage에 저장 실행
        saveSettings(); 

        updateHeaderModelDisplay(); 
        closeModal('core-modal'); 
        showMessage("✅ 설정이 브라우저에 저장되었습니다.");
    } catch(e) { 
        alert("저장 실패: " + e.message); 
    }
}


function updateHeaderModelDisplay() {
    const modelDisplay = document.getElementById('model-display');
    if (!modelDisplay) return;

    // 현재 설정된 공급자 확인
    const provider = SETTINGS.aiProvider || 'gemini';
    
    // 제미니면 SETTINGS.currentModel, 아니면 SETTINGS.customModel 표시
    const modelName = (provider === 'gemini') 
        ? (SETTINGS.currentModel || 'Gemini Pro') 
        : (SETTINGS.customModel || 'Custom API');
    
    modelDisplay.innerText = 'Model: ' + modelName;
}

        function switchCoreTab(t) { 
            document.querySelectorAll('.core-tab-content').forEach(e => e.classList.add('hidden')); 
            const targetTab = document.getElementById('core-tab-' + t);
            if(targetTab) targetTab.classList.remove('hidden'); 
            
            // Desktop button highlighting logic
            document.querySelectorAll('#core-modal-nav-desktop button').forEach(btn => {
                const btnValue = btn.onclick.toString().match(/switchCoreTab\(['"](.*?)['"]\)/)?.[1];
                if (btnValue === t) {
                    btn.classList.add('bg-indigo-50', 'text-indigo-700');
                } else {
                    btn.classList.remove('bg-indigo-50', 'text-indigo-700');
                }
            });


            // Mobile select synchronization
            const mobileSelect = document.getElementById('core-tab-select-mobile');
            if (mobileSelect && mobileSelect.value !== t) {
                mobileSelect.value = t;
            }
        }
        
// ▼▼▼ [수정] 모달 내 지침 리스트 렌더링 (기능 강화) ▼▼▼
function renderCoreRules() { 
    const l = document.getElementById('core-rules-list'); 
    l.innerHTML = ''; 


    SETTINGS.coreRules.forEach((r, i) => {
        const isEnabled = r.enabled !== false;
        
        // *팁: 여기서 onchange 이벤트를 통해 데이터를 실시간으로 수정합니다.
        l.innerHTML += `
        <div class="rule-item border bg-gray-50 mb-2 rounded overflow-hidden collapsed ${isEnabled ? '' : 'disabled'}">
            <div class="rule-header flex justify-between items-center p-3 bg-gray-100 cursor-pointer" onclick="this.parentElement.classList.toggle('collapsed')">
                <div class="flex items-center gap-2" onclick="event.stopPropagation()">
                    <input type="checkbox" ${isEnabled ? 'checked' : ''} 
                        onchange="SETTINGS.coreRules[${i}].enabled = this.checked; this.closest('.rule-item').classList.toggle('disabled', !this.checked);" 
                        class="w-4 h-4 cursor-pointer text-indigo-600 focus:ring-indigo-500">
                    
                    <span class="font-bold text-sm text-gray-700 dark:text-gray-300 select-none">
                        ${r.title || '규칙 ' + (i + 1)}
                    </span>
                </div>
                <button onclick="event.stopPropagation(); if(confirm('삭제하시겠습니까?')){ SETTINGS.coreRules.splice(${i},1); renderCoreRules(); }" class="text-red-500 hover:text-red-700 text-xs font-bold px-2 py-1">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            
            <div class="rule-content p-3 border-t bg-white dark:bg-slate-800">
                <div class="mb-2">
                    <label class="block text-xs font-bold text-gray-500 mb-1">지침 제목</label>
                    <input class="w-full p-2 border rounded text-sm bg-gray-50 dark:bg-slate-700 dark:border-slate-600 dark:text-white" 
                        value="${String(r.title).replace(/"/g, '&quot;')}" 
                        onchange="SETTINGS.coreRules[${i}].title = this.value; this.closest('.rule-item').querySelector('.font-bold').innerText = this.value;">
                </div>
                <div>
                    <label class="block text-xs font-bold text-gray-500 mb-1">상세 내용</label>
                    <textarea class="w-full p-2 border rounded text-sm h-32 leading-relaxed bg-gray-50 dark:bg-slate-700 dark:border-slate-600 dark:text-white resize-none focus:ring-2 focus:ring-indigo-500" 
                        onchange="SETTINGS.coreRules[${i}].content = this.value">${r.content}</textarea>
                </div>
            </div>
        </div>`;
    });
    
    // 생성된 모든 textarea에 리사이즈 핸들 부착 (편의성)
    l.querySelectorAll('textarea').forEach(el => makeResizable(el));
}


/* ▼▼▼ [수정됨] 용어/표현 지침 렌더링 (리사이즈 핸들 추가) ▼▼▼ */
function renderDicRules() { 
    const l=document.getElementById('core-dic-list'); l.innerHTML=''; 
    SETTINGS.dicRules.forEach((r,i)=> {
        l.innerHTML+=`<div class="rule-item border bg-gray-50 mb-2 rounded overflow-hidden collapsed">
            <div class="rule-header flex justify-between items-center p-3 bg-gray-100 cursor-pointer" onclick="this.parentElement.classList.toggle('collapsed')">
                <span class="font-bold text-sm"><i class="fa-solid fa-chevron-down mr-2 text-gray-500"></i>${r.title||'용어 '+(i+1)}</span>
                <button onclick="event.stopPropagation(); SETTINGS.dicRules.splice(${i},1);renderDicRules()" class="text-red-500 hover:text-red-700 text-xs font-bold">삭제</button>
            </div>
            <div class="rule-content p-3 border-t">
                <input class="w-full mb-2 p-2 border rounded text-sm" value="${r.title}" placeholder="용어" onchange="SETTINGS.dicRules[${i}].title=this.value">
                <textarea class="w-full p-2 border rounded text-sm h-32" onchange="SETTINGS.dicRules[${i}].content=this.value">${r.content}</textarea>
            </div>
        </div>`;
    });
    
    // [추가됨] 생성된 모든 textarea에 리사이즈 핸들 부착
    l.querySelectorAll('textarea').forEach(el => makeResizable(el));
}
        
        function addEntryUI(id, data) { if(id==='core-rules-list') SETTINGS.coreRules.push(data); else SETTINGS.dicRules.push(data); if(id==='core-rules-list') renderCoreRules(); else renderDicRules(); }
        function openMemoryModal() { if(AppState.sessionId) { document.getElementById('memory-input').value = DB.chats.find(c=>c.id===AppState.sessionId).memory||''; openModalInternal('memory-modal'); } }
        function saveMemory() { 
            if(AppState.sessionId) { 
                DB.chats.find(c=>c.id===AppState.sessionId).memory = document.getElementById('memory-input').value; 
                saveData(); 
                closeModal('memory-modal'); 
                showMessage('장기 기억이 저장되었습니다.'); // 저장 확인 메시지 추가
            } 
        }
        function openTextareaEditor(btn) { AppState.activeTextareaTarget = btn.closest('div').querySelector('textarea'); document.getElementById('modal-textarea-input').value = AppState.activeTextareaTarget.value; openModalInternal('textarea-editor-modal'); }
        function saveAndCloseTextareaEditor() { if(AppState.activeTextareaTarget) AppState.activeTextareaTarget.value = document.getElementById('modal-textarea-input').value; closeModal('textarea-editor-modal'); }
        
function addGlobalLoreFromSidebar() {
    if (!SETTINGS.globalLorebook) SETTINGS.globalLorebook = [];
    
    // 빈 로어 생성
    SETTINGS.globalLorebook.push({ id: Date.now(), title: '새 로어', keywords: '', content: '' });
    saveSettings();
    renderRightSidebar();
    
    // 방금 생성한 로어의 에디터 즉시 열기
    editGlobalLore(SETTINGS.globalLorebook.length - 1);
}


function editGlobalLore(idx) {
    const lore = SETTINGS.globalLorebook[idx];
    const body = document.getElementById('modal-body');


    // 1. 에디터 UI 주입 (제목, 키워드, 내용 입력창)
    body.innerHTML = `
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">로어 제목</label>
                <input id="quick-lore-title" type="text" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100 focus:ring-2 focus:ring-indigo-500" value="${String(lore.title || '').replace(/"/g, '&quot;')}" placeholder="예: 마법 체계, 제국 역사">
            </div>
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-400 mb-1">감지 키워드 (콤마로 구분)</label>
                <input id="quick-lore-keys" type="text" class="w-full p-2 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100 text-sm focus:ring-2 focus:ring-indigo-500" value="${String(lore.keywords || '').replace(/"/g, '&quot;')}" placeholder="비워두면 항상 적용">
                <p class="text-[10px] text-gray-400 mt-1">* 대화나 지문에 이 단어가 등장할 때만 AI에게 설정이 주입됩니다.</p>
            </div>
            <div>
                <label class="block text-sm font-bold text-gray-700 dark:text-gray-300 mb-1">내용</label>
                <textarea id="quick-lore-content" rows="15" class="w-full p-3 border rounded-lg bg-white dark:bg-slate-700 dark:border-slate-600 dark:text-gray-100 resize-none text-sm leading-relaxed focus:ring-2 focus:ring-indigo-500" placeholder="상세 설정을 입력하세요...">${lore.content || ''}</textarea>
            </div>
        </div>
    `;


    // 2. 모달 설정
    document.getElementById('modal-title').innerText = "글로벌 로어북 수정";
    document.getElementById('modal-delete-btn').classList.add('hidden');
    document.getElementById('btn-gen-details').classList.add('hidden');


    // 3. 저장 로직
    document.getElementById('modal-save-btn').onclick = () => {
        const titleVal = document.getElementById('quick-lore-title').value.trim();
        if (!titleVal) return alert("제목을 입력해주세요.");


        SETTINGS.globalLorebook[idx].title = titleVal;
        SETTINGS.globalLorebook[idx].keywords = document.getElementById('quick-lore-keys').value;
        SETTINGS.globalLorebook[idx].content = document.getElementById('quick-lore-content').value;


        saveSettings();
        renderRightSidebar();
        closeModal('editor-modal');
    };


    // 4. 모달 열기 및 기능 활성화
    openModalInternal('editor-modal');
    setTimeout(() => {
        const textarea = document.getElementById('quick-lore-content');
        if (textarea) {
            textarea.focus();
            makeResizable(textarea); // 리사이즈 핸들 부착
        }
    }, 50);
}


        function deleteGlobalLore(idx) { if(confirm("삭제하시겠습니까?")) { SETTINGS.globalLorebook.splice(idx, 1); saveSettings(); renderRightSidebar(); } }


// [수정] 기존 showLastPrompt 함수를 이걸로 통째로 교체하세요
function showLastPrompt() {
    if (!AppState.lastSentPrompt) return alert("아직 전송된 데이터가 없습니다.");

            const textarea = document.getElementById('modal-textarea-input');
            
            // 토큰 정보가 있으면 맨 위에 표시
            let infoHeader = "";
            if (AppState.lastTokenUsage) {
                infoHeader = `[📊 토큰 사용량 보고서(추정)]\n` +
                             `• 보낸 양 (Prompt): ${AppState.lastTokenUsage.promptTokenCount} 토큰\n` +
                             `• 받은 양 (Output): ${AppState.lastTokenUsage.candidatesTokenCount} 토큰\n` +
                             `• 합계 (Total): ${AppState.lastTokenUsage.totalTokenCount} 토큰\n` +
                             `--------------------------------------------------\n\n`;
            } else {
                infoHeader = `[📊 토큰 정보 없음]\nAPI에서 사용량 정보를 받지 못했습니다.\n\n`;
            }


            textarea.value = infoHeader + AppState.lastSentPrompt;
            document.getElementById('modal-textarea-input').scrollTop = 0;
            
            // 모달 제목 변경
            const titleEl = document.querySelector('#textarea-editor-modal h3');
            titleEl.innerText = "디버그: 토큰 및 데이터 확인";
            
            openModalInternal('textarea-editor-modal');
            
            // 닫을 때 제목 복구
            const closeBtn = document.querySelector('#textarea-editor-modal button[onclick*="saveAndClose"]');
            const oldOnClick = closeBtn.onclick;
            closeBtn.onclick = function() {
                titleEl.innerText = "전체 화면 편집";
                oldOnClick();
            };
        }


// [추가] 사이드바에서 북마크 삭제 (화면 이동 없음)
        function deleteBookmarkFromSidebar(index) {
            const chat = DB.chats.find(c => c.id === AppState.sessionId);
            if(chat) {
                // 1. 데이터에서 해제
                chat.history[index].bookmarked = false;
                saveData();
                
                // 2. 사이드바 목록 즉시 갱신
                renderRightSidebar(); 
                
                // 3. (중요) 현재 채팅창에 해당 메시지가 보인다면, 아이콘을 즉시 지워서 시각적 동기화
                // (loadSession을 호출하면 스크롤이 튀기 때문에, DOM만 살짝 건드리는 방식 사용)
                const msgEl = document.querySelector(`.msg-wrapper[data-index="${index}"]`);
                if(msgEl) {
                     // 상단 노란색 북마크 뱃지 제거
                     const indicator = msgEl.querySelector('.fa-bookmark.text-yellow-500')?.closest('div.absolute');
                     if(indicator) indicator.remove();
                     
                     // 툴바의 북마크 버튼 상태 초기화 (채워진 아이콘 -> 빈 아이콘)
                     const btnIcon = msgEl.querySelector('.msg-tools button[onclick*="toggleBookmark"] i');
                     const btn = msgEl.querySelector('.msg-tools button[onclick*="toggleBookmark"]');
                     if(btnIcon && btn) {
                         btnIcon.className = 'fa-regular fa-bookmark text-xs';
                         btn.className = btn.className.replace('text-yellow-500', '').replace('hover:text-yellow-600', '') + ' text-gray-400 hover:text-yellow-600';
                     }
                }
            }
        }


        // [추가] 다크 모드 토글 및 저장 함수
        function toggleDarkMode() {
            const isDark = document.getElementById('dark-mode-toggle').checked;
            if (isDark) {
                document.documentElement.classList.add('dark');
                localStorage.setItem('novel_ai_dark_mode', 'true');
            } else {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('novel_ai_dark_mode', 'false');
            }
        }


/* ▼▼▼ [수정] 3단계: 장기 기억 (초상세/대용량 모드) ▼▼▼ */
async function generateAutoSummary() {
    if(!AppState.sessionId) return alert("대화 내용이 없습니다.");
    if(!SETTINGS.apiKey) return alert("API 키가 필요합니다.");
    
    // 확인 메시지도 명확하게 변경
    if(!confirm("현재까지의 대화 내용을 바탕으로 '장기 기억'을 대폭 확장합니다.\n(단순 요약이 아닌, 상세한 연대기 및 설정집 형태로 갱신됩니다.)")) return;


    const textarea = document.getElementById('memory-input');
    const loadingOverlay = document.getElementById('modal-loading-overlay-memory');
    const chat = DB.chats.find(c => c.id === AppState.sessionId);
    
    const existingMemory = chat.memory || "없음(None)";
    // [수정] 참조 범위를 최근 20턴 -> 50턴으로 대폭 확대하여 문맥 확보
    const recentHistory = chat.history.slice(-50).map(m => `[${m.role}]: ${m.text}`).join('\n'); 


    loadingOverlay.classList.remove('hidden');
    loadingOverlay.classList.add('flex');
    
    // [수정] 요약이 아닌 '상세 기록'을 위한 강력한 프롬프트
    const prompt = `
    You are the 'Chief Archivist' for a massive novel project.
    Your goal is to maintain a [Long-term Memory] file that is extremely detailed, like a Wiki or a Logbook.
    
    [Instructions]
    1. **DO NOT SUMMARIZE.** Do not condense information. Instead, **ACCUMULATE and EXPAND** it.
    2. **Review the [Existing Memory]**: Preserve all details from the existing memory. Do not delete anything unless it is explicitly contradicted by recent events.
    3. **Integrate [Recent Conversation]**: Append new details found in the recent conversation (last 50 turns) into the memory structure.
    4. **Detail Level**: Aim for a length of 5,000 ~ 10,000 characters if necessary. Be verbose. Capture specific dialogues, item acquisitions, emotional shifts, and minor plot points.
    5. **Structure**: Organize the output in the following format (Markdown):
    
    # 1. Current Status (현재 상황)
    (Time, Location, Current Goal, Physical/Mental State of characters)
    
    # 2. Chronological Log (상세 연대기)
    - (Past Events from Existing Memory...)
    - (New Events from Recent Conversation...) -> Write these in detail. Who said what? What happened?
    
    # 3. Character & Relationship Details (인물 및 관계 심화)
    (Update personality changes, hidden secrets revealed, intimacy levels)
    
    # 4. Inventory & Quest (소지품 및 과제)
    (List items gained/lost, current active quests or objectives)
    
    [Input Data]
    === Existing Memory ===
    ${existingMemory}
    
    === Recent Conversation (Last 50 turns) ===
    ${recentHistory}
    
    [Language]
    MUST BE KOREAN (한국어).
    `;


    try {
        const modelToUse = SETTINGS.currentModel || 'gemini-3-pro';
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${SETTINGS.apiKey}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
                // [수정] 출력 토큰을 최대치(8192)로 설정하여 짤림 방지
                generationConfig: {
                    maxOutputTokens: 8192, 
                    temperature: 0.7 
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            })
        });


        const data = await response.json();
        if (data.candidates && data.candidates[0].content) {
            textarea.value = data.candidates[0].content.parts[0].text;
            showMessage("장기 기억이 상세하게 확장되었습니다.");
        } else {
            throw new Error("AI 응답 없음");
        }
    } catch (e) {
        alert("기억 확장 실패: " + e.message);
    } finally {
        loadingOverlay.classList.add('hidden');
        loadingOverlay.classList.remove('flex');
    }
}


/* --- [추가] 스마트 로어북 감지 엔진 --- */
function detectActiveLore(allEntries, contextText) {
    const activeEntries = [];
    const triggeredTitles = [];
    
    // 검색 대상 텍스트 정규화 (대소문자 무시 등)
    const textToCheck = contextText.toLowerCase();


    (allEntries || []).forEach(entry => {
        // 1. 내용이나 제목이 없으면 스킵
        if (!entry.content && !entry.title) return;


        // 2. 키워드가 비어있으면? -> '항시 적용(Passive)'으로 간주
        if (!entry.keywords || entry.keywords.trim() === '') {
            activeEntries.push(entry);
            return;
        }


        // 3. 키워드 매칭 검사 (콤마로 구분된 키워드 중 하나라도 있으면 발동)
        const keys = entry.keywords.split(',').map(k => k.trim().toLowerCase()).filter(k => k);
        const isMatch = keys.some(key => textToCheck.includes(key));


        if (isMatch) {
            activeEntries.push(entry);
            triggeredTitles.push(entry.title); // 발동된 설정 제목 저장
        }
    });


    return { entries: activeEntries, triggers: triggeredTitles };
}


/* --- [신규 기능] 매크로(단축 문구) 시스템 --- */


// 1. 팝업 토글 및 렌더링
function toggleMacroPopup() {
    const popup = document.getElementById('macro-popup');
    if (popup.classList.contains('hidden')) {
        renderMacroChips();
        popup.classList.remove('hidden');
        popup.classList.add('flex');
    } else {
        popup.classList.add('hidden');
        popup.classList.remove('flex');
    }
}


// [수정] 칩 렌더링 (type="button" 추가하여 자동 전송 방지)
function renderMacroChips() {
    const popup = document.getElementById('macro-popup');
    popup.innerHTML = '';
    
    if (!SETTINGS.macros || SETTINGS.macros.length === 0) {
        popup.innerHTML = '<span class="text-xs text-gray-400 p-2">설정에서 단축 문구를 추가하세요.</span>';
        return;
    }


    SETTINGS.macros.forEach(macro => {
        const btn = document.createElement('button');
        btn.type = 'button'; // [중요] 이 줄이 없으면 누르자마자 전송됩니다!
        btn.className = "flex-shrink-0 bg-indigo-100 text-indigo-700 px-3 py-1.5 rounded-full text-xs font-bold hover:bg-indigo-200 transition border border-indigo-200";
        btn.innerText = macro.label;
        
        // 클릭 이벤트
        btn.onclick = (e) => {
            e.preventDefault(); // 혹시 모를 기본 동작 차단
            insertAtCursor(document.getElementById('msg-input'), macro.content);
            
            // 모바일에서는 클릭 후 팝업 닫기 (불편하면 이 줄 삭제)
            if(window.innerWidth < 768) toggleMacroPopup();
        };
        popup.appendChild(btn);
    });
    
    // 설정 바로가기 버튼
    const setBtn = document.createElement('button');
    setBtn.type = 'button'; // [중요] 설정 버튼도 전송 방지
    setBtn.className = "flex-shrink-0 bg-gray-100 text-gray-500 px-3 py-1.5 rounded-full text-xs hover:bg-gray-200 transition border border-gray-200";
    setBtn.innerHTML = '<i class="fa-solid fa-cog"></i>';
    setBtn.onclick = (e) => { 
        e.preventDefault();
        toggleMacroPopup(); 
        openCoreModal(); 
        switchCoreTab('macro'); 
    };
    popup.appendChild(setBtn);
}


/* --- [최종 수정] 텍스트 삽입 함수 (단순 붙여넣기 모드) --- */
function insertAtCursor(textarea, text) {
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const originalValue = textarea.value;
    
    // 1. 텍스트 삽입 (기존 내용 사이에 끼워넣기)
    textarea.value = originalValue.substring(0, start) + text + originalValue.substring(end);
    
    // 2. 포커스 맞추기
    textarea.focus();
    
    // 3. 커서를 무조건 '삽입된 텍스트의 맨 끝'으로 이동
    const newPos = start + text.length;
    textarea.selectionStart = textarea.selectionEnd = newPos;
}




/* --- 설정 화면(Core Modal) 관련 로직 추가 --- */


// [수정됨] 매크로 설정 목록 렌더링 (순서 변경 버튼 추가)
function renderMacroSettings() {
    const list = document.getElementById('macro-list');
    if (!list) return;
    list.innerHTML = '';
    
    if (!SETTINGS.macros) SETTINGS.macros = [];


    SETTINGS.macros.forEach((macro, index) => {
        const div = document.createElement('div');
        div.className = "flex gap-2 items-center bg-white p-2 border rounded shadow-sm";
        
        // 첫 번째 항목은 위로 못 가고, 마지막 항목은 아래로 못 가도록 숨김 처리
        const upClass = index === 0 ? 'opacity-0 pointer-events-none' : 'hover:text-indigo-600';
        const downClass = index === SETTINGS.macros.length - 1 ? 'opacity-0 pointer-events-none' : 'hover:text-indigo-600';


        div.innerHTML = `
            <div class="flex flex-col items-center justify-center mr-1 gap-0.5">
                <button onclick="moveMacro(${index}, -1)" class="text-gray-400 ${upClass} leading-none" title="위로"><i class="fa-solid fa-caret-up"></i></button>
                <button onclick="moveMacro(${index}, 1)" class="text-gray-400 ${downClass} leading-none" title="아래로"><i class="fa-solid fa-caret-down"></i></button>
            </div>
            <input type="text" class="w-1/3 p-2 border rounded text-sm bg-gray-50" placeholder="버튼 이름" value="${macro.label}" onchange="updateMacro(${index}, 'label', this.value)">
            <input type="text" class="flex-1 p-2 border rounded text-sm" placeholder="입력될 내용" value="${macro.content}" onchange="updateMacro(${index}, 'content', this.value)">
            <button onclick="deleteMacro(${index})" class="text-gray-400 hover:text-red-500 p-2"><i class="fa-solid fa-trash"></i></button>
        `;
        list.appendChild(div);
    });
}


// [신규] 매크로 순서 이동 함수
function moveMacro(index, direction) {
    const targetIndex = index + direction;
    
    // 배열 범위를 벗어나지 않는지 확인 (유효성 검사)
    if (targetIndex >= 0 && targetIndex < SETTINGS.macros.length) {
        // 배열 내 요소 순서 맞바꾸기 (Swap)
        const temp = SETTINGS.macros[index];
        SETTINGS.macros[index] = SETTINGS.macros[targetIndex];
        SETTINGS.macros[targetIndex] = temp;
        
        // 변경된 순서로 목록 다시 그리기
        renderMacroSettings();
    }
}




function addMacroUI() {
    SETTINGS.macros.push({ label: '새 버튼', content: '' });
    renderMacroSettings();
}


function updateMacro(index, key, value) {
    SETTINGS.macros[index][key] = value;
}


function deleteMacro(index) {
    if(confirm('이 단축 문구를 삭제하시겠습니까?')) {
        SETTINGS.macros.splice(index, 1);
        renderMacroSettings();
    }
}


// [신규] API 키 보이기/숨기기 토글 함수
function toggleApiKeyVisibility() {
    const input = document.getElementById('core-api-key');
    const icon = document.getElementById('api-key-icon');
    
    if (input.type === 'password') {
        input.type = 'text'; // 보이게 전환
        icon.classList.remove('fa-eye');
        icon.classList.add('fa-eye-slash');
    } else {
        input.type = 'password'; // 숨기게 전환
        icon.classList.remove('fa-eye-slash');
        icon.classList.add('fa-eye');
    }
}


// ▼▼▼ [리팩토링 2단계] 타이핑 효과 엔진 (TypingEngine) ▼▼▼
const TypingEngine = {
    timer: null,
    start: function(text, element) {
        if(this.timer) clearInterval(this.timer);
        AppState.isTyping = true;
        const speed = SETTINGS.typingSpeed || 15; 
        const chars = text.split('');
        let rendered = '';
        this.timer = setInterval(() => {
            const area = document.getElementById('content-area');
            const isNearBottom = area.scrollHeight - area.scrollTop - area.clientHeight < 150;
            if(chars.length > 0) {
                rendered += chars.shift();
                if(element) element.innerHTML = marked.parse(rendered, { breaks: true });
                if (isNearBottom) this.scrollToBottom();
            } else { this.stop(); }
        }, speed);
    },
    stop: function() {
        clearInterval(this.timer); AppState.isTyping = false;
        if (AppState.currentMsgElement) {
            const choices = AppState.currentMsgElement.closest('.msg-wrapper').querySelector('.choices-container');
            if (choices) {
                choices.classList.remove('max-h-0', 'opacity-0');
                choices.classList.add('mt-4', 'pt-2', 'border-t', 'border-gray-200', 'max-h-[1000px]', 'opacity-100');
            }
        }
        saveData(); 
    },
    scrollToBottom: function() {
        const d = document.getElementById('content-area'); 
        if(d) d.scrollTop = d.scrollHeight;
    }
};

/* --- [수정됨] AIEngine 전체 리팩토링 (생략 없음) --- */
/* --- MODIFY START: AIEngine 리팩토링 완성본 --- */
const AIEngine = {
    // 1. 응답 생성 (Provider 분기 처리)
    generateResponse: async function(chat, signalObj) {
        const provider = SETTINGS.aiProvider || 'gemini';
        if (provider === 'gemini') {
            if (!SETTINGS.apiKey) throw new Error("Gemini API 키가 설정되지 않았습니다.");
            return this.callGeminiAPI(chat, signalObj);
        } else {
            if (!SETTINGS.customBaseUrl) throw new Error("Base URL이 설정되지 않았습니다.");
            if (!SETTINGS.customApiKey) throw new Error("Custom API Key가 설정되지 않았습니다.");
            return this.callOpenAICompatible(chat, signalObj);
        }
    },

    // 2. 소설 연출 설정 추출
    _getNovelSettings: function() {
        const maps = {
            viewpoint: { '3인칭 제한적 시점 (추천)': 'Viewpoint: Third-person limited (Focus on Protagonist).', '3인칭 제한적 (히로인 내면)': 'Viewpoint: Third-person limited (Focus on Heroine).', '1인칭 주인공 시점': 'Viewpoint: First-person (I...).', '3인칭 관찰자 시점': 'Viewpoint: Third-person Objective.', '3인칭 전지적 작가 시점': 'Viewpoint: Third-person Omniscient.' },
            style: { '웹소설체': 'Style: Webnovel.', '간결/건조체': 'Style: Hardboiled.', '만연/화려체': 'Style: Flowery.' },
            pacing: { '빠른 전개 (사건 위주)': 'Pacing: FAST.', '보통 (밸런스)': 'Pacing: BALANCED.', '느린 전개 (세밀한 묘사)': 'Pacing: SLOW.' },
            atmosphere: { '유쾌/코믹 (가벼운 분위기)': 'Atmosphere: Lighthearted.', '일상/힐링 (포근한 분위기)': 'Atmosphere: Cozy.', '담백/건조 (사실적 묘사)': 'Atmosphere: Dry.', '진지/시리어스 (무거운 서사)': 'Atmosphere: Serious.', '피폐/느와르 (어둡고 절망적)': 'Atmosphere: Noir.', '공포/스릴러 (긴장감 조성)': 'Atmosphere: Horror.', '달달/로맨스 (설레는 무드)': 'Atmosphere: Sweet.', '관능/퇴폐 (끈적한 분위기)': 'Atmosphere: Sensual.' },
            nsfw: { '전연령 (스킨십/키스)': 'Safety: Mild/Romance.', '노멀 (성관계 해금)': 'Safety: R-18.', '고수위 (자극적/적나라함)': 'Safety: R-18/Explicit.', '초고수위 (에로게/동인지)': 'Safety: Extreme/Hentai.' },
            attitude: { '철벽 (차가움/방어적)': 'Attitude: Cold.', '도도함 (오만/내려다봄)': 'Attitude: Arrogant.', '보통 (일반적)': 'Attitude: Neutral.', '적극적 (유혹/리드)': 'Attitude: Active.', '금사빠 (맹목적 애정)': 'Attitude: Clingy.' },
            ratio: { '밸런스형': 'Ratio: Balanced.', '여자 발언 위주': 'Ratio: Female dialogue focused.', '대화 중심': 'Ratio: Dialogue Heavy.', '지문/묘사 중심': 'Ratio: Description Heavy.' },
            length: { '짧게 (150단어 내외)': 'Length: SHORT.', '보통 (400단어 내외)': 'Length: MEDIUM.', '길게 (800단어 이상)': 'Length: LONG.' }
        };

        const getSettingStr = (key, map) => {
            const isEnabled = SETTINGS[key + '_enabled'] !== false; 
            if (!isEnabled) return '';
            const val = SETTINGS[key];
            return (val && map[val]) ? map[val] : '';
        };

        return [
            getSettingStr('novelViewpoint', maps.viewpoint),
            getSettingStr('novelStyle', maps.style),
            getSettingStr('novelPacing', maps.pacing),
            getSettingStr('novelAtmosphere', maps.atmosphere),
            getSettingStr('nsfwLevel', maps.nsfw),
            getSettingStr('charAttitude', maps.attitude),
            getSettingStr('novelRatio', maps.ratio),
            getSettingStr('outputLength', maps.length)
        ].filter(s => s !== '').join('\n');
    },

/* --- MODIFY START: 배경 미선택 시에도 로어북 작동 및 소설 원문 감지 --- */
    _getWorldContext: function(chat) {
        const w = DB.worlds.find(x => x.id === chat.worldId);
        
        // [수정됨] 감지 텍스트 조립: 히스토리(15턴) + 소설 원문(있는 경우)
        let contextText = chat.history.slice(-15).map(h => h.text).join('\n');
        if (chat.novelContent) contextText += '\n' + chat.novelContent;

        // 전역 로어북은 배경 유무와 상관없이 항상 체크
        const activeGlobalLore = detectActiveLore(SETTINGS.globalLorebook, contextText);
        
        // 배경 로어북은 배경이 있을 때만 체크
        const activeWorldLore = w ? detectActiveLore(w.lorebook, contextText) : { entries: [], triggers: [] };
        
        const worldDescription = w ? `[WORLD SETTING]\nName: ${w.name}\nDescription: ${w.description || 'No description'}` : "[MODE: Novel/General]";
        const userPersona = (w && w.user) ? `[USER PERSONA]\nName: ${w.user.name}\nFeatures: ${w.user.features}` : "";
        
        const loreStr = [...activeGlobalLore.entries, ...activeWorldLore.entries]
            .map(l => `[Lore: ${l.title}]\n${l.content}`).join('\n');
            
        const rulesStr = w ? (w.aiRules || []).filter(r => r.enabled !== false)
            .map(r => `[World Rule: ${r.title}] ${r.content}`).join('\n') : "";

        return { description: worldDescription, lore: loreStr, rules: rulesStr, user: userPersona };
    },
/* --- MODIFY END --- */

    // 4. 캐릭터 컨텍스트 정리
    _getCharacterContext: function(chat) {
        const w = DB.worlds.find(x => x.id === chat.worldId);
        if (!w || !chat.characterIds?.length) return "";

        return (w.characters || []).filter(c => chat.characterIds.includes(c.id)).map(c => {
            const extraEntries = (c.entries || []).filter(e => e.enabled !== false).map(e => `[${e.title}] ${e.content}`).join('\n');
            return `
[CHARACTER: ${c.name}]
- Core: ${c.gender}, ${c.age}yrs, ${c.race}, ${c.job}
- Appearance: ${c.appearance_desc} (Hair: ${c.hair_style}, Eyes: ${c.eyes})
- Mental: ${c.personality_tags} / Voice: ${c.voice}
- Sexual: Zone: ${c.erogenous_zones}, Fetish: ${c.fetish}, Traits: ${c.perverted_features}
- Depth: ${c.dialogue_depth || ''} / ${c.sexual_psyche || ''} / ${c.sexual_behavior || ''}
${extraEntries ? `- Extra Info:\n${extraEntries}` : ''}
- Sample Dialogue:\n${c.sample_dialogue || ''}`;
        }).join('\n');
    },

// 5. 프롬프트 조립
buildChatPrompt: function(chat) {
        const novelSettings = this._getNovelSettings();
        const worldCtx = this._getWorldContext(chat);
        const charCtx = this._getCharacterContext(chat);

        // 유저의 첫 메시지 시점(length 1)을 분석 단계로 판별
const isFirstMove = chat.history.length <= 1;
        const hasImages = chat.novelImages && chat.novelImages.length > 0;

        let imageInstruction = "";
        if (hasImages) {
            imageInstruction = `
[VISUAL ANALYSIS & USER SELECTION PROTOCOL]
이미지가 제공되었습니다. AI는 다음 정보를 정밀 분석하여 'text' 필드에 작성하십시오. 알 수 없다면 임의로 설정하십시오.
1. 캐릭터 프로필: 캐릭터 이름, 직업, 성격, 외모(헤어스타일), 신체 특징(가슴, 엉덩이, 골반 등 몸매 상세), 복장 및 스타일.
2. 배경 및 상황: 세계관, 상황, 장소, 소품, 조명, 인물의 자세와 표정, 인간관계.

${isFirstMove ? `
[STRICT RULE: NO STORY NARRATIVE]
현재는 이야기의 '발단' 전 분석 단계입니다. 
- **'text' 필드에는 소설 본문(서사/이야기)을 절대 작성하지 마십시오.** - 오직 위 1~2번 항목에 대한 [분석 결과]만 상세히 나열하십시오.
- 반드시 다음 3가지 유형의 선택지(choices)를 구성하여 제시하십시오:
  * 선택지 1 (시작부터): 발단부터 이야기 시작.
  * 선택지 2 (이어서): 직후의 행동으로 연결.
  * 선택지 3 (참고만): 이미지는 가이드로만 활용하고 새로운 상황에서 시작.
` : "분석된 시각적 특징(신체 묘사 포함)을 소설 서술에 자연스럽게 반영하여 이야기를 이어가십시오."}
`;
        }

        const systemPrompt = `
[SYSTEM IDENTITY]
Role: Professional Novel AI specializing in high-quality storytelling.
Language: KOREAN (한국어).

${imageInstruction}

[STYLE & PACING]
${novelSettings}

[CONTEXT]
${worldCtx.description}
${worldCtx.user}
${charCtx}

[RULES & LORE]
${worldCtx.lore}
${worldCtx.rules}
${(SETTINGS.coreRules || []).filter(r => r.enabled !== false).map(r => `[Core Rule: ${r.title}] ${r.content}`).join('\n')}
${chat.memory ? `[MEMORY]\n${chat.memory}` : ''}

[RESPONSE FORMAT: JSON ONLY]
${(hasImages && isFirstMove) ? 
'Output Structure: { "text": "[분석 결과]\\n(여기에 소설 본문 없이 캐릭터 및 상황 분석 내용만 작성)", "choices": ["...", "...", "..."] }' : 
'Output Structure: { "text": "(소설 본문 서술...)", "choices": ["...", "...", "..."] }'}
`;

        const contents = chat.history.filter(h => h.role === 'user' || h.role === 'model').map(h => ({
            role: h.role === 'user' ? 'user' : 'model',
            parts: [{ text: h.text }]
        }));

        if (chat.novelImages?.length > 0) {
            const imgParts = chat.novelImages.map(img => ({ inlineData: { mimeType: 'image/jpeg', data: img.split(',')[1] } }));
            if (!contents.length) contents.push({ role: 'user', parts: imgParts });
            else if (contents[0].role === 'user') contents[0].parts = [...imgParts, ...contents[0].parts];
        }

AppState.lastSentPrompt = systemPrompt;
        return {
            system_instruction: { parts: [{ text: systemPrompt }] },
            contents: contents,
            safetySettings: SETTINGS.uncensored ? [
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }
            ] : [],
            generationConfig: {
                // [수정] Number()를 사용하여 확실하게 숫자로 변환
                maxOutputTokens: Number(SETTINGS.maxOutputTokens) || 4000,
                temperature: Number(SETTINGS.temperature) || 0.9,
                response_mime_type: "application/json"
            }
        };
    },

    // 6. Gemini 호출
    callGeminiAPI: async function(chat, signalObj) {
        const requestBody = this.buildChatPrompt(chat);
        const modelToUse = SETTINGS.currentModel || 'gemini-3-pro-preview';
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelToUse}:generateContent?key=${SETTINGS.apiKey}`;

        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody),
            signal: signalObj
        });

        const data = await res.json();
        if (data.error) throw new Error(data.error.message);
        if (data.usageMetadata) AppState.lastTokenUsage = data.usageMetadata;
        return data.candidates[0].content.parts[0].text;
    },

    // 7. OpenAI 호환 호출
    callOpenAICompatible: async function(chat, signalObj) {
        const geminiData = this.buildChatPrompt(chat);
        const systemText = geminiData.system_instruction.parts[0].text;
        const messages = [{ role: "system", content: systemText }];
        geminiData.contents.forEach(msg => {
            messages.push({ role: msg.role === 'model' ? 'assistant' : 'user', content: msg.parts[0].text });
        });

        const baseUrl = (SETTINGS.customBaseUrl || 'https://openrouter.ai/api/v1').replace(/\/$/, '');
const res = await fetch(`${baseUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${SETTINGS.customApiKey}` },
            body: JSON.stringify({
                model: SETTINGS.customModel || 'gpt-4o',
                messages: messages,
                // [수정] parseFloat()를 사용하여 소수점 숫자로 확실하게 변환
                temperature: parseFloat(SETTINGS.temperature) || 0.9,
                max_tokens: Number(SETTINGS.maxOutputTokens) || 4000
            }),
            signal: signalObj
        });

        const data = await res.json();
        if (data.error) throw new Error(data.error.message);
        return data.choices[0].message.content;
    },

summarizeChat: async function(chatId) {
        const chat = DB.chats.find(c => c.id === chatId);
        if(!chat || chat.history.length < 2) return; 

        const historyText = chat.history.map(m => m.text).join('\n').substring(0, 1000);
        const prompt = `Story Context: ${historyText}\n\nTask: Create a short Korean title and one Emoji. JSON: { "title": "제목", "emoji": "😎" }`;

        try {
            // [수정됨] 하드코딩된 Google URL fetch 대신 requestAI를 사용하여 조립합니다.
            const reply = await this.requestAI(prompt, null);
            const text = reply.replace(/```json|```/g,'').trim();
            const result = JSON.parse(text);
            
            chat.title = result.title; 
            chat.emoji = result.emoji;
            
            if (AppState.sessionId === chatId) {
                document.getElementById('header-title').innerText = chat.title;
            }
            renderSidebar();
            saveData();
        } catch(e) { 
            console.error("Summary failed", e); 
        }
    },

// 9. [통합됨] 일반 텍스트 요청 (생성기/상세설정 채우기용)
    requestAI: async function(prompt, signalObj) {
        const provider = SETTINGS.aiProvider || 'gemini';
        
        if (provider === 'gemini') {
            const model = SETTINGS.currentModel || 'gemini-3-pro-preview';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${SETTINGS.apiKey}`;
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    contents: [{ parts: [{ text: prompt }] }],
                    safetySettings: SETTINGS.uncensored ? [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ] : []
                }),
                signal: signalObj
            });
            const data = await res.json();
            if (data.error) throw new Error(data.error.message);
            if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]) throw new Error("AI 응답 없음 (차단됨)");
            return data.candidates[0].content.parts[0].text;
        } else {
            const baseUrl = (SETTINGS.customBaseUrl || 'https://openrouter.ai/api/v1').replace(/\/$/, '');
            const res = await fetch(`${baseUrl}/chat/completions`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SETTINGS.customApiKey}`
                },
                body: JSON.stringify({
                    model: SETTINGS.customModel || 'gpt-4o',
                    messages: [{ role: "user", content: prompt }],
                    temperature: 0.7
                }),
                signal: signalObj
            });
            const data = await res.json();
            if (data.error) throw new Error(data.error.message || "API 요청 실패");
            return data.choices[0].message.content;
        }
    }
}; // [중요] 여기서 AIEngine 객체가 딱 한 번만 닫혀야 합니다.
/* --- MODIFY END --- */

// ▼▼▼ [Bridge] 호환성 연결 (MessageManager가 이 함수를 부릅니다) ▼▼▼
window.callGemini = function(chat, signalObj) { return AIEngine.generateResponse(chat, signalObj); };
function generateChatSummary(chatId) { AIEngine.summarizeChat(chatId); }

const MessageManager = {
    // 1. 전송 메인
    send: async function(txt = null) {
        const input = document.getElementById('msg-input');
        let text = txt || input.value.trim();
        if (!text || AppState.isGenerating) return;

        if (!AppState.sessionId) {
            const newId = Date.now().toString();
            DB.chats.unshift({ id: newId, title: text.substring(0, 15), worldId: 'quick_dummy', history: [], isNovelMode: true });
            loadSession(newId);
        }

        const chat = DB.chats.find(c => c.id === AppState.sessionId);
        text = this._parseChoice(text, chat);

const chatIndex = DB.chats.findIndex(c => c.id === AppState.sessionId);
        if (chatIndex > 0) {
            const [targetChat] = DB.chats.splice(chatIndex, 1);
            DB.chats.unshift(targetChat);
        }

        input.value = '';

        this._backupChoices(chat);
        chat.history.push({ role: 'user', text: text });
        appendMessage({ role: 'user', text: text }, false);
        
        saveData(); renderSidebar();
        await this._executeAI(chat, AppState.sessionId);
    },

    // 2. 선택지 파싱
    _parseChoice: function(text, chat) {
        const match = text.match(/^([1-4])/);
        if (match && chat.history.length > 0) {
            const last = chat.history[chat.history.length - 1];
            if (last.choices) {
                const arr = Array.isArray(last.choices) ? last.choices : last.choices.split('\n');
                const idx = parseInt(match[1]) - 1;
                if (arr[idx]) return arr[idx].replace(/^[0-9]+[\.\)]\s*/, '');
            }
        }
        return text;
    },

    // 3. 선택지 제거
    _backupChoices: function(chat) {
        if (chat.history.length > 0) {
            const last = chat.history[chat.history.length - 1];
            if (last.choices) { last.backup_choices = last.choices; last.choices = null; loadSession(chat.id); }
        }
    },

    // 4. AI 실행
_executeAI: async function(chat, sid) {
        AppState.isGenerating = true;
        if (AppState.abortController) AppState.abortController.abort();
        AppState.abortController = new AbortController();
        updateSendButtonState('generating');

        try {
            const reply = await AIEngine.generateResponse(chat, AppState.abortController.signal);
            let content = "", choices = null;
            
            // [수정됨] 슈퍼 루틴 파서 v2: 괄호 노출 절대 차단 모드
            try {
                // 1. 코드 블록 및 앞뒤 공백 제거
                let clean = reply.replace(/```json/gi, '').replace(/```/g, '').trim();
                const start = clean.indexOf('{');
                const end = clean.lastIndexOf('}');
                
if (start !== -1 && end !== -1) {
                    let jsonStr = clean.substring(start, end + 1);
                    
                    // 비표준 JSON 보정 (줄바꿈 및 특수문자 이스케이프)
                    const sanitizedJson = jsonStr
                        .replace(/\n/g, '\\n') 
                        .replace(/\r/g, '\\r')
                        .replace(/\t/g, '\\t');

                    try {
                        const parsed = JSON.parse(sanitizedJson);
                        content = parsed.text || "";
                        choices = parsed.choices || null;
                    } catch (innerE) {
                        // [수정됨] JSON 파싱 실패 시 정규식으로 안전하게 추출
                        const textMatch = jsonStr.match(/"text"\s*:\s*"([\s\S]*?)"\s*(?=[,}])/);
                        if (textMatch) content = textMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"').trim();
                        
                        const choicesMatch = jsonStr.match(/"choices"\s*:\s*\[([\s\S]*?)\]/);
                        if (choicesMatch) {
                            // [수정됨] 쉼표 버그 해결: 쉼표로 자르지 않고 따옴표 덩어리를 찾음
                            const innerContent = choicesMatch[1];
                            const regex = /"(?:[^"\\]|\\.)*"/g; 
                            const matches = innerContent.match(regex);
                            
                            if (matches) {
                                choices = matches.map(s => s.substring(1, s.length - 1) // 앞뒤 따옴표 제거
                                    .replace(/\\"/g, '"')
                                    .replace(/\\n/g, '\n')
                                    .replace(/\\/g, '')
                                    .trim());
                            }
                        }
                    }
                }
                
                // 4. [중요] 모든 추출 실패 시 안전장치: 괄호가 포함된 모든 영역을 물리적으로 삭제
                if (!content || content.trim() === "") {
                    content = clean.replace(/\{[\s\S]*\}/g, '').trim();
                }
                
                // 5. 최종 확인: 여전히 비어있거나 파싱 흔적이 남았다면 원문 대신 에러 처리
                if (!content) {
                    content = (reply.includes('{')) ? "내용을 불러오는 중 오류가 발생했습니다. (JSON 파싱 실패)" : reply;
                }

            } catch (e) {
                console.error("Critical Parser Error:", e);
                content = "응답 데이터 구조가 올바르지 않습니다.";
            }

if (AppState.sessionId === sid) {
                // [수정됨] 정제 순서 변경: 줄바꿈과 따옴표를 먼저 복구한 뒤 남은 역슬래시를 지웁니다.
                content = content
                    .replace(/\\n/g, '\n')       // 1. \n 문자열을 실제 줄바꿈(엔터)으로 최우선 변환
                    .replace(/\\"/g, '"')        // 2. 이스케이프된 따옴표 복구
                    .replace(/\\'/g, "'")        // 3. 이스케이프된 작은따옴표 복구
                    .replace(/\\/g, '')          // 4. 그러고 나서 남은 쓰레기 역슬래시만 제거
                    .replace(/"text"\s*:\s*"/g, '') 
                    .replace(/",?\s*$/g, '')
                    .trim();

                chat.history.push({ role: 'model', text: content, choices: choices });
                appendMessage({ role: 'model', text: content, choices: choices }, true);
                if (chat.history.length === 2) AIEngine.summarizeChat(chat.id);
                saveData(); 
                renderSidebar();
            }
        } catch (e) {
            if (e.name !== 'AbortError') appendMessage({ role: 'model', text: `오류: ${e.message}` }, false);
        } finally {
            AppState.isGenerating = false; 
            updateSendButtonState('idle'); 
            scrollToBottom();
        }
    },

delete: function(idx) {
        const chat = DB.chats.find(c => c.id === AppState.sessionId);
        if (chat && confirm('이 메시지를 삭제하시겠습니까?')) {
            // [수정됨] 선택지 복구 로직: 삭제하는 메시지 이전 메시지에 백업된 선택지가 있다면 복구
            if (idx > 0) {
                const prevMsg = chat.history[idx - 1];
                if (prevMsg && prevMsg.backup_choices) {
                    prevMsg.choices = prevMsg.backup_choices;
                    prevMsg.backup_choices = null;
                }
            }

            chat.history.splice(idx, 1); 
            saveData(); 
            loadSession(chat.id);
            showMessage("메시지가 삭제되었습니다.");
        }
    },

    reroll: async function(idx) {
        const chat = DB.chats.find(c => c.id === AppState.sessionId);
        if (chat) {
            chat.history = chat.history.slice(0, idx);
            saveData(); loadSession(chat.id);
            await this._executeAI(chat, chat.id);
        }
    },

    copy: function(idx) {
        const chat = DB.chats.find(c => c.id === AppState.sessionId);
        if (chat) {
            const ta = document.createElement("textarea");
            ta.value = chat.history[idx].text; document.body.appendChild(ta);
            ta.select(); document.execCommand('copy'); ta.remove();
            showMessage("📋 복사됨");
        }
    },

    toggleEdit: function(idx, type) {
        const v = document.getElementById(`${type}-view-${idx}`), e = document.getElementById(`${type}-editor-${idx}`);
        if (e.classList.contains('hidden')) {
            v.classList.add('hidden'); e.classList.remove('hidden');
            const chat = DB.chats.find(c => c.id === AppState.sessionId);
            let val = chat.history[idx][type] || '';
            e.querySelector('textarea').value = Array.isArray(val) ? val.join('\n') : val;
        } else { v.classList.remove('hidden'); e.classList.add('hidden'); }
    },

    saveEdit: function(idx, type) {
        const chat = DB.chats.find(c => c.id === AppState.sessionId);
        const val = document.getElementById(`${type}-editor-${idx}`).querySelector('textarea').value;
        chat.history[idx][type] = type === 'choices' ? val.split('\n').filter(l => l.trim()) : val;
        saveData(); loadSession(chat.id); showMessage('✅ 저장됨');
    }
};

// ▼▼▼ [필수 Bridge] HTML onclick 이벤트 연결용 ▼▼▼
function sendMessage(txt) { MessageManager.send(txt); }
function deleteMessage(idx) { MessageManager.delete(idx); }
function rerollMessage(idx) { MessageManager.reroll(idx); }
function copyMessage(idx) { MessageManager.copy(idx); }
function toggleEditMode(idx, type) { MessageManager.toggleEdit(idx, type); }
function saveEditData(idx, type) { MessageManager.saveEdit(idx, type); }
function scrollToBottom() { TypingEngine.scrollToBottom(); }


const UIRenderer = {
    // 메시지 HTML 생성 메인 함수
    createMsgHTML: function(msg, index) {
        const isUser = msg.role === 'user', isDirector = msg.role === 'director', isBookmarked = msg.bookmarked || false;
        
        // 버튼 공통 스타일 클래스 (테두리 및 배경 호버 효과 추가) [수정됨]
        const btnClass = "w-8 h-8 flex items-center justify-center rounded-full border border-transparent hover:border-indigo-200 hover:bg-indigo-50 hover:text-indigo-600 transition-all duration-200 text-gray-400";
        
        return `
            ${isBookmarked ? `<div class="absolute -top-3 left-1/2 -translate-x-1/2 text-yellow-500 text-xs z-10"><i class="fa-solid fa-bookmark"></i></div>` : ''}
            <div class="msg-container relative">
                <div class="msg-tools absolute right-0 -bottom-8 flex gap-1 opacity-0 group-hover:opacity-100 transition p-1 z-10">
                    <button onclick="toggleBookmark(${index})" class="${btnClass} ${isBookmarked ? 'text-yellow-500 border-yellow-200 bg-yellow-50' : ''}" title="책갈피 설정/해제">
                        <i class="fa-bookmark ${isBookmarked ? 'fa-solid' : 'fa-regular'} text-xs"></i>
                    </button>
                    <button onclick="toggleEditMode(${index}, 'text')" class="${btnClass}" title="내용 수정">
                        <i class="fa-solid fa-pen text-xs"></i>
                    </button>
                    ${!isUser && !isDirector ? `
                    <button onclick="rerollMessage(${index})" class="${btnClass}" title="다시 생성">
                        <i class="fa-solid fa-rotate-right text-xs"></i>
                    </button>` : ''}
                    <button onclick="copyMessage(${index})" class="${btnClass}" title="복사하기">
                        <i class="fa-regular fa-copy text-xs"></i>
                    </button>
                    <button onclick="deleteMessage(${index})" class="${btnClass}" title="삭제하기">
                        <i class="fa-solid fa-trash text-xs"></i>
                    </button>
                </div>
                <div id="text-view-${index}"><div class="novel-text ${isUser ? 'user-text' : 'model-text'}" id="msg-content-${index}"></div></div>
                <div id="text-editor-${index}" class="hidden mt-2">
                    <textarea class="w-full p-3 text-sm border rounded-lg bg-white mb-2" rows="5">${msg.text}</textarea>
                    <div class="flex justify-end gap-2">
                        <button onclick="toggleEditMode(${index}, 'text')" class="px-3 py-1 text-xs text-gray-500">취소</button>
                        <button onclick="saveEditData(${index}, 'text')" class="px-3 py-1 text-xs bg-indigo-600 text-white rounded font-bold">저장</button>
                    </div>
                </div>
                ${this._renderChoices(msg, index)}
            </div>`;
    },

    // [수정됨] 선택지 렌더링 (자바스크립트 문법 에러 완벽 방지)
_renderChoices: function(msg, index) {
        if (!msg.choices) return '';
        const arr = Array.isArray(msg.choices) ? msg.choices : msg.choices.split('\n').filter(l => l.trim());
        
        const list = arr.map((c, i) => {
            // [수정됨] 역슬래시는 지우되 큰따옴표(")는 유지합니다.
            let cleanText = c.trim()
                .replace(/\\"/g, '"') // \" 를 " 로 복구
                .replace(/\\/g, '')  // 남은 역슬래시만 제거
                .replace(/^[0-9]+[\.\)]\s*/, ''); // 앞쪽 번호 제거

            // 자바스크립트 클릭 이벤트에서 터지지 않게 최소한의 이스케이프만 수행
            const safeText = cleanText
                .replace(/'/g, "\\'")
                .replace(/"/g, '&quot;'); 

            return `
                <li onclick="selectOption('${safeText}')" class="choice-item p-3 hover:bg-indigo-50 cursor-pointer rounded-lg border border-gray-100 mb-2 bg-white flex shadow-sm transition-all duration-200">
                    <span class="mr-2 text-indigo-400 font-bold">${i+1}.</span>
                    ${cleanText}
                </li>`;
        }).join('');

        return `
            <div id="choices-view-${index}" class="choices-container overflow-hidden transition-all duration-700 max-h-0 opacity-0">
                <div class="text-[10px] font-bold text-gray-400 mb-2 uppercase tracking-widest">Choices</div>
                <ul class="space-y-1">${list}</ul>
            </div>
            `;
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());


// OpenAI용 API Key 보이기/숨기기 토글 기능
function toggleCustomApiKeyVisibility() {
    const input = document.getElementById('core-custom-key');
    const icon = document.getElementById('custom-api-key-icon');
    
    if (input.type === 'password') {
        input.type = 'text'; // 텍스트로 변경 (보임)
        icon.classList.replace('fa-eye', 'fa-eye-slash');
    } else {
        input.type = 'password'; // 패스워드로 변경 (숨김)
        icon.classList.replace('fa-eye-slash', 'fa-eye');
    }
}

    </script>
</body>
</html>